// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.2 (swiftlang-5.7.2.135.5 clang-1400.0.29.51)
// swift-module-flags: -target arm64-apple-ios12.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Display
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AVFoundation
import Accelerate
import AppBundle
import AsyncDisplayKit
import AudioToolbox
import CoreGraphics
import CoreHaptics
import CoreMedia
import CoreText
@_exported import Display
import Foundation
import Markdown
import MediaPlayer
import ObjCRuntimeUtils
import Swift
import SwiftSignalKit
import UIKit.UIGestureRecognizerSubclass
import UIKit
import UIKitRuntimeUtils
import _Concurrency
import _StringProcessing
public protocol PresentableController : AnyObject {
  func viewDidAppear(completion: @escaping () -> Swift.Void)
}
public protocol ContainableController : AnyObject {
  var view: UIKit.UIView! { get }
  var displayNode: AsyncDisplayKit.ASDisplayNode { get }
  var isViewLoaded: Swift.Bool { get }
  var isOpaqueWhenInOverlay: Swift.Bool { get }
  var blocksBackgroundWhenInOverlay: Swift.Bool { get }
  var ready: SwiftSignalKit.Promise<Swift.Bool> { get }
  var updateTransitionWhenPresentedAsModal: ((CoreFoundation.CGFloat, Display.ContainedViewLayoutTransition) -> Swift.Void)? { get set }
  func combinedSupportedOrientations(currentOrientationToLock: UIKit.UIInterfaceOrientationMask) -> Display.ViewControllerSupportedOrientations
  var deferScreenEdgeGestures: UIKit.UIRectEdge { get }
  var prefersOnScreenNavigationHidden: Swift.Bool { get }
  func containerLayoutUpdated(_ layout: Display.ContainerViewLayout, transition: Display.ContainedViewLayoutTransition)
  func updateToInterfaceOrientation(_ orientation: UIKit.UIInterfaceOrientation)
  func updateModalTransition(_ value: CoreFoundation.CGFloat, transition: Display.ContainedViewLayoutTransition)
  func preferredContentSizeForLayout(_ layout: Display.ContainerViewLayout) -> CoreFoundation.CGSize?
  func viewWillAppear(_ animated: Swift.Bool)
  func viewWillDisappear(_ animated: Swift.Bool)
  func viewDidAppear(_ animated: Swift.Bool)
  func viewDidDisappear(_ animated: Swift.Bool)
}
@objc final public class CollectionIndexNode : AsyncDisplayKit.ASDisplayNode {
  public static let searchIndex: Swift.String
  final public var indexSelected: ((Swift.String) -> Swift.Void)?
  @objc override dynamic public init()
  @objc override final public func didLoad()
  final public func update(size: CoreFoundation.CGSize, color: UIKit.UIColor, sections: [Swift.String], transition: Display.ContainedViewLayoutTransition)
  @objc override final public func hitTest(_ point: CoreFoundation.CGPoint, with event: UIKit.UIEvent?) -> UIKit.UIView?
  @objc deinit
}
@_hasMissingDesignatedInitializers public class StatusBarSurface {
  @objc deinit
}
@objc @_inheritsConvenienceInitializers open class CallStatusBarNode : AsyncDisplayKit.ASDisplayNode {
  open func update(size: CoreFoundation.CGSize)
  @objc override dynamic public init()
  @objc override dynamic public init(viewBlock: @escaping AsyncDisplayKit.ASDisplayNodeViewBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc override dynamic public init(layerBlock: @escaping AsyncDisplayKit.ASDisplayNodeLayerBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc deinit
}
@objc final public class StatusBar : AsyncDisplayKit.ASDisplayNode {
  final public var statusBarStyle: Display.StatusBarStyle {
    get
    set(value)
  }
  final public func updateStatusBarStyle(_ statusBarStyle: Display.StatusBarStyle, animated: Swift.Bool)
  final public var ignoreInCall: Swift.Bool
  final public var verticalOffset: CoreFoundation.CGFloat {
    get
    set
  }
  final public func updateAlpha(_ alpha: CoreFoundation.CGFloat, transition: Display.ContainedViewLayoutTransition)
  @objc override dynamic public init()
  @objc override final public func hitTest(_ point: CoreFoundation.CGPoint, with event: UIKit.UIEvent?) -> UIKit.UIView?
  @objc deinit
}
public enum ListViewItemHeaderStickDirection {
  case top
  case topEdge
  case bottom
  public static func == (a: Display.ListViewItemHeaderStickDirection, b: Display.ListViewItemHeaderStickDirection) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol ListViewItemHeader : AnyObject {
  var id: Display.ListViewItemNode.HeaderId { get }
  var stickDirection: Display.ListViewItemHeaderStickDirection { get }
  var height: CoreFoundation.CGFloat { get }
  var stickOverInsets: Swift.Bool { get }
  func combinesWith(other: Display.ListViewItemHeader) -> Swift.Bool
  func node(synchronousLoad: Swift.Bool) -> Display.ListViewItemHeaderNode
  func updateNode(_ node: Display.ListViewItemHeaderNode, previous: Display.ListViewItemHeader?, next: Display.ListViewItemHeader?)
}
@objc open class ListViewItemHeaderNode : AsyncDisplayKit.ASDisplayNode {
  open func updateFlashingOnScrolling(_ isFlashingOnScrolling: Swift.Bool, animated: Swift.Bool)
  public init(layerBacked: Swift.Bool = false, dynamicBounce: Swift.Bool = false, isRotated: Swift.Bool = false, seeThrough: Swift.Bool = false)
  open func updateStickDistanceFactor(_ factor: CoreFoundation.CGFloat, transition: Display.ContainedViewLayoutTransition)
  public func animate(_ timestamp: Swift.Double) -> Swift.Bool
  open func animateRemoved(duration: Swift.Double)
  open func animateAdded(duration: Swift.Double)
  open func updateLayout(size: CoreFoundation.CGSize, leftInset: CoreFoundation.CGFloat, rightInset: CoreFoundation.CGFloat)
  open func updateAbsoluteRect(_ rect: CoreFoundation.CGRect, within containerSize: CoreFoundation.CGSize)
  public func updateFrame(_ frame: CoreFoundation.CGRect, within containerSize: CoreFoundation.CGSize, updateFrame: Swift.Bool = true)
  @objc deinit
}
public func addAccessibilityChildren(of node: AsyncDisplayKit.ASDisplayNode, container: Any, to list: inout [Any])
public func smartInvertColorsEnabled() -> Swift.Bool
public func isReduceMotionEnabled() -> SwiftSignalKit.Signal<Swift.Bool, SwiftSignalKit.NoError>
public func isSpeakSelectionEnabled() -> Swift.Bool
public func isSpeakSelectionEnabledSignal() -> SwiftSignalKit.Signal<Swift.Bool, SwiftSignalKit.NoError>
public func isBoldTextEnabled() -> SwiftSignalKit.Signal<Swift.Bool, SwiftSignalKit.NoError>
public enum ToolbarActionOption {
  case left
  case right
  case middle
  public static func == (a: Display.ToolbarActionOption, b: Display.ToolbarActionOption) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class ToolbarTheme {
  final public let barBackgroundColor: UIKit.UIColor
  final public let barSeparatorColor: UIKit.UIColor
  final public let barTextColor: UIKit.UIColor
  final public let barSelectedTextColor: UIKit.UIColor
  public init(barBackgroundColor: UIKit.UIColor, barSeparatorColor: UIKit.UIColor, barTextColor: UIKit.UIColor, barSelectedTextColor: UIKit.UIColor)
  @objc deinit
}
@objc final public class ToolbarNode : AsyncDisplayKit.ASDisplayNode {
  final public var left: () -> Swift.Void
  final public var right: () -> Swift.Void
  final public var middle: () -> Swift.Void
  public init(theme: Display.ToolbarTheme, displaySeparator: Swift.Bool = false, left: @escaping () -> Swift.Void = {}, right: @escaping () -> Swift.Void = {}, middle: @escaping () -> Swift.Void = {})
  final public func updateTheme(_ theme: Display.ToolbarTheme)
  final public func updateLayout(size: CoreFoundation.CGSize, leftInset: CoreFoundation.CGFloat, rightInset: CoreFoundation.CGFloat, additionalSideInsets: UIKit.UIEdgeInsets, bottomInset: CoreFoundation.CGFloat, toolbar: Display.Toolbar, transition: Display.ContainedViewLayoutTransition)
  @objc deinit
}
public enum ActionSheetButtonColor {
  case accent
  case destructive
  case disabled
  public static func == (a: Display.ActionSheetButtonColor, b: Display.ActionSheetButtonColor) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ActionSheetButtonFont {
  case `default`
  case bold
  public static func == (a: Display.ActionSheetButtonFont, b: Display.ActionSheetButtonFont) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class ActionSheetButtonItem : Display.ActionSheetItem {
  final public let title: Swift.String
  final public let color: Display.ActionSheetButtonColor
  final public let font: Display.ActionSheetButtonFont
  final public let enabled: Swift.Bool
  final public let action: () -> Swift.Void
  public init(title: Swift.String, color: Display.ActionSheetButtonColor = .accent, font: Display.ActionSheetButtonFont = .default, enabled: Swift.Bool = true, action: @escaping () -> Swift.Void)
  public func node(theme: Display.ActionSheetControllerTheme) -> Display.ActionSheetItemNode
  public func updateNode(_ node: Display.ActionSheetItemNode)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class ActionSheetButtonNode : Display.ActionSheetItemNode {
  override public init(theme: Display.ActionSheetControllerTheme)
  @objc override dynamic public func didLoad()
  override public func updateLayout(constrainedSize: CoreFoundation.CGSize, transition: Display.ContainedViewLayoutTransition) -> CoreFoundation.CGSize
  @objc deinit
}
public enum NavigationBarContentMode {
  case replacement
  case expansion
  public static func == (a: Display.NavigationBarContentMode, b: Display.NavigationBarContentMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers open class NavigationBarContentNode : AsyncDisplayKit.ASDisplayNode {
  open var requestContainerLayout: (Display.ContainedViewLayoutTransition) -> Swift.Void
  open var height: CoreFoundation.CGFloat {
    get
  }
  open var clippedHeight: CoreFoundation.CGFloat {
    get
  }
  open var nominalHeight: CoreFoundation.CGFloat {
    get
  }
  open var mode: Display.NavigationBarContentMode {
    get
  }
  open func updateLayout(size: CoreFoundation.CGSize, leftInset: CoreFoundation.CGFloat, rightInset: CoreFoundation.CGFloat, transition: Display.ContainedViewLayoutTransition)
  @objc override dynamic public init()
  @objc override dynamic public init(viewBlock: @escaping AsyncDisplayKit.ASDisplayNodeViewBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc override dynamic public init(layerBlock: @escaping AsyncDisplayKit.ASDisplayNodeLayerBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc deinit
}
public protocol CustomNavigationTransitionNode : AsyncDisplayKit.ASDisplayNode {
  func setup(topNavigationBar: Display.NavigationBar, bottomNavigationBar: Display.NavigationBar)
  func update(containerSize: CoreFoundation.CGSize, fraction: CoreFoundation.CGFloat, transition: Display.ContainedViewLayoutTransition)
  func restore()
}
public protocol ListViewAccessoryItem {
  func isEqualToItem(_ other: Display.ListViewAccessoryItem) -> Swift.Bool
  func node(synchronous: Swift.Bool) -> Display.ListViewAccessoryItemNode
}
public protocol TooltipControllerCustomContentNode : AsyncDisplayKit.ASDisplayNode {
  func animateIn()
  func updateLayout(size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
}
public enum TooltipControllerContent : Swift.Equatable {
  case text(Swift.String)
  case attributedText(Foundation.NSAttributedString)
  case iconAndText(UIKit.UIImage, Swift.String)
  case custom(Display.TooltipControllerCustomContentNode)
  public static func == (lhs: Display.TooltipControllerContent, rhs: Display.TooltipControllerContent) -> Swift.Bool
}
public enum SourceAndRect {
  case node(() -> (AsyncDisplayKit.ASDisplayNode, CoreFoundation.CGRect)?)
  case view(() -> (UIKit.UIView, CoreFoundation.CGRect)?)
}
final public class TooltipControllerPresentationArguments {
  final public let sourceAndRect: Display.SourceAndRect
  public init(sourceNodeAndRect: @escaping () -> (AsyncDisplayKit.ASDisplayNode, CoreFoundation.CGRect)?)
  public init(sourceViewAndRect: @escaping () -> (UIKit.UIView, CoreFoundation.CGRect)?)
  @objc deinit
}
@objc @_Concurrency.MainActor(unsafe) open class TooltipController : Display.ViewController, Display.StandalonePresentableController {
  @_Concurrency.MainActor(unsafe) public var content: Display.TooltipControllerContent {
    get
  }
  @_Concurrency.MainActor(unsafe) open func updateContent(_ content: Display.TooltipControllerContent, animated: Swift.Bool, extendTimer: Swift.Bool, arrowOnBottom: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) public var dismissed: ((Swift.Bool) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) public init(content: Display.TooltipControllerContent, baseFontSize: CoreFoundation.CGFloat, timeout: Swift.Double = 2.0, dismissByTapOutside: Swift.Bool = false, dismissByTapOutsideSource: Swift.Bool = false, dismissImmediatelyOnLayoutUpdate: Swift.Bool = false, arrowOnBottom: Swift.Bool = true, padding: CoreFoundation.CGFloat = 8.0)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(coder aDecoder: Foundation.NSCoder)
  @objc deinit
  @_Concurrency.MainActor(unsafe) override open func loadDisplayNode()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) override open func containerLayoutUpdated(_ layout: Display.ContainerViewLayout, transition: Display.ContainedViewLayoutTransition)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) override open func dismiss(completion: (() -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) open func dismissImmediately()
}
public enum ActionSheetControllerThemeBackgroundType {
  case light
  case dark
  public static func == (a: Display.ActionSheetControllerThemeBackgroundType, b: Display.ActionSheetControllerThemeBackgroundType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class ActionSheetControllerTheme : Swift.Equatable {
  final public let dimColor: UIKit.UIColor
  final public let backgroundType: Display.ActionSheetControllerThemeBackgroundType
  final public let itemBackgroundColor: UIKit.UIColor
  final public let itemHighlightedBackgroundColor: UIKit.UIColor
  final public let standardActionTextColor: UIKit.UIColor
  final public let destructiveActionTextColor: UIKit.UIColor
  final public let disabledActionTextColor: UIKit.UIColor
  final public let primaryTextColor: UIKit.UIColor
  final public let secondaryTextColor: UIKit.UIColor
  final public let controlAccentColor: UIKit.UIColor
  final public let controlColor: UIKit.UIColor
  final public let switchFrameColor: UIKit.UIColor
  final public let switchContentColor: UIKit.UIColor
  final public let switchHandleColor: UIKit.UIColor
  final public let baseFontSize: CoreFoundation.CGFloat
  public init(dimColor: UIKit.UIColor, backgroundType: Display.ActionSheetControllerThemeBackgroundType, itemBackgroundColor: UIKit.UIColor, itemHighlightedBackgroundColor: UIKit.UIColor, standardActionTextColor: UIKit.UIColor, destructiveActionTextColor: UIKit.UIColor, disabledActionTextColor: UIKit.UIColor, primaryTextColor: UIKit.UIColor, secondaryTextColor: UIKit.UIColor, controlAccentColor: UIKit.UIColor, controlColor: UIKit.UIColor, switchFrameColor: UIKit.UIColor, switchContentColor: UIKit.UIColor, switchHandleColor: UIKit.UIColor, baseFontSize: CoreFoundation.CGFloat)
  public static func == (lhs: Display.ActionSheetControllerTheme, rhs: Display.ActionSheetControllerTheme) -> Swift.Bool
  @objc deinit
}
extension QuartzCore.CALayer {
  public func addShakeAnimation(amplitude: CoreFoundation.CGFloat = 3.0, duration: Swift.Double = 0.3, count: Swift.Int = 4, decay: Swift.Bool = false)
}
public func addCorners(_ context: Display.DrawingContext, arguments: Display.TransformImageArguments)
public protocol Interpolatable {
  static func interpolator() -> (Display.Interpolatable, Display.Interpolatable, CoreFoundation.CGFloat) -> (Display.Interpolatable)
}
extension CoreFoundation.CGFloat : Display.Interpolatable {
  public static func interpolator() -> (Display.Interpolatable, Display.Interpolatable, CoreFoundation.CGFloat) -> Display.Interpolatable
}
extension UIKit.UIEdgeInsets : Display.Interpolatable {
  public static func interpolator() -> (Display.Interpolatable, Display.Interpolatable, CoreFoundation.CGFloat) -> Display.Interpolatable
}
extension CoreFoundation.CGRect : Display.Interpolatable {
  public static func interpolator() -> (Display.Interpolatable, Display.Interpolatable, CoreFoundation.CGFloat) -> Display.Interpolatable
}
extension CoreFoundation.CGPoint : Display.Interpolatable {
  public static func interpolator() -> (Display.Interpolatable, Display.Interpolatable, CoreFoundation.CGFloat) -> Display.Interpolatable
}
public let listViewAnimationCurveSystem: (_ t: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
public let listViewAnimationCurveLinear: (_ t: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
public let listViewAnimationCurveEaseInOut: (_ t: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
public func listViewAnimationCurveFromAnimationOptions(animationOptions: UIKit.UIView.AnimationOptions) -> (CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
@_hasMissingDesignatedInitializers final public class ListViewAnimation {
  public init<T>(from: T, to: T, duration: Swift.Double, invertOffsetDirection: Swift.Bool = false, curve: @escaping (CoreFoundation.CGFloat) -> CoreFoundation.CGFloat, beginAt: Swift.Double, update: @escaping (CoreFoundation.CGFloat, T) -> Swift.Void, completed: @escaping (Swift.Bool) -> Swift.Void = { _ in }) where T : Display.Interpolatable
  final public func completeAt(_ timestamp: Swift.Double) -> Swift.Bool
  final public func cancel()
  final public func applyAt(_ timestamp: Swift.Double)
  @objc deinit
}
public func listViewAnimationDurationAndCurve(transition: Display.ContainedViewLayoutTransition) -> (Swift.Double, Display.ListViewAnimationCurve)
@objc @_inheritsConvenienceInitializers final public class PassthroughContainerNode : AsyncDisplayKit.ASDisplayNode {
  @objc override final public func hitTest(_ point: CoreFoundation.CGPoint, with event: UIKit.UIEvent?) -> UIKit.UIView?
  @objc override dynamic public init()
  @objc override dynamic public init(viewBlock: @escaping AsyncDisplayKit.ASDisplayNodeViewBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc override dynamic public init(layerBlock: @escaping AsyncDisplayKit.ASDisplayNodeLayerBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc deinit
}
@objc open class ASButtonNode : AsyncDisplayKit.ASControlNode {
  final public let titleNode: Display.ImmediateTextNode
  final public let highlightedTitleNode: Display.ImmediateTextNode
  final public let disabledTitleNode: Display.ImmediateTextNode
  final public let imageNode: Display.ASImageNode
  final public let highlightedImageNode: Display.ASImageNode
  final public let selectedImageNode: Display.ASImageNode
  final public let highlightedSelectedImageNode: Display.ASImageNode
  final public let disabledImageNode: Display.ASImageNode
  final public let backgroundImageNode: Display.ASImageNode
  final public let highlightedBackgroundImageNode: Display.ASImageNode
  public var contentEdgeInsets: UIKit.UIEdgeInsets {
    get
    set
  }
  public var contentHorizontalAlignment: AsyncDisplayKit.ASHorizontalAlignment {
    get
    set
  }
  public var laysOutHorizontally: Swift.Bool {
    get
    set
  }
  public var contentSpacing: CoreFoundation.CGFloat {
    get
    set
  }
  @objc override dynamic public init()
  @objc override dynamic open func calculateSizeThatFits(_ constrainedSize: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  open func setAttributedTitle(_ title: Foundation.NSAttributedString, for state: UIKit.UIControl.State)
  open func attributedTitle(for state: UIKit.UIControl.State) -> Foundation.NSAttributedString?
  open func setTitle(_ title: Swift.String, with font: UIKit.UIFont, with color: UIKit.UIColor, for state: UIKit.UIControl.State)
  open func setImage(_ image: UIKit.UIImage?, for state: UIKit.UIControl.State)
  open func setBackgroundImage(_ image: UIKit.UIImage?, for state: UIKit.UIControl.State)
  open func image(for state: UIKit.UIControl.State) -> UIKit.UIImage?
  open func backgroundImage(for state: UIKit.UIControl.State) -> UIKit.UIImage?
  @objc override dynamic open var isSelected: Swift.Bool {
    @objc get
    @objc set
  }
  @objc override dynamic open var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  open var isImplicitlyDisabled: Swift.Bool {
    get
    set
  }
  @objc override dynamic open var isEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @objc override dynamic open func layout()
  @objc deinit
}
public struct Font {
  public enum Design {
    case regular
    case serif
    case monospace
    case round
    case camera
    public static func == (a: Display.Font.Design, b: Display.Font.Design) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct Traits : Swift.OptionSet {
    public var rawValue: Swift.Int32
    public init(rawValue: Swift.Int32)
    public init()
    public static let italic: Display.Font.Traits
    public static let monospacedNumbers: Display.Font.Traits
    public typealias ArrayLiteralElement = Display.Font.Traits
    public typealias Element = Display.Font.Traits
    public typealias RawValue = Swift.Int32
  }
  public enum Weight {
    case regular
    case light
    case medium
    case semibold
    case bold
    case heavy
    public static func == (a: Display.Font.Weight, b: Display.Font.Weight) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static func with(size: CoreFoundation.CGFloat, design: Display.Font.Design = .regular, weight: Display.Font.Weight = .regular, traits: Display.Font.Traits = []) -> UIKit.UIFont
  public static func regular(_ size: CoreFoundation.CGFloat) -> UIKit.UIFont
  public static func medium(_ size: CoreFoundation.CGFloat) -> UIKit.UIFont
  public static func semibold(_ size: CoreFoundation.CGFloat) -> UIKit.UIFont
  public static func bold(_ size: CoreFoundation.CGFloat) -> UIKit.UIFont
  public static func heavy(_ size: CoreFoundation.CGFloat) -> UIKit.UIFont
  public static func light(_ size: CoreFoundation.CGFloat) -> UIKit.UIFont
  public static func semiboldItalic(_ size: CoreFoundation.CGFloat) -> UIKit.UIFont
  public static func monospace(_ size: CoreFoundation.CGFloat) -> UIKit.UIFont
  public static func semiboldMonospace(_ size: CoreFoundation.CGFloat) -> UIKit.UIFont
  public static func italicMonospace(_ size: CoreFoundation.CGFloat) -> UIKit.UIFont
  public static func semiboldItalicMonospace(_ size: CoreFoundation.CGFloat) -> UIKit.UIFont
  public static func italic(_ size: CoreFoundation.CGFloat) -> UIKit.UIFont
}
extension Foundation.NSAttributedString {
  convenience public init(string: Swift.String, font: UIKit.UIFont? = nil, textColor: UIKit.UIColor = UIColor.black, paragraphAlignment: UIKit.NSTextAlignment? = nil)
}
public protocol NavigationBarTitleTransitionNode {
  func makeTransitionMirrorNode() -> AsyncDisplayKit.ASDisplayNode
}
@objc final public class PageControlNode : AsyncDisplayKit.ASDisplayNode {
  final public var dotColor: UIKit.UIColor {
    get
    set
  }
  final public var inactiveDotColor: UIKit.UIColor {
    get
    set
  }
  public init(dotSize: CoreFoundation.CGFloat = 7.0, dotSpacing: CoreFoundation.CGFloat = 9.0, dotColor: UIKit.UIColor, inactiveDotColor: UIKit.UIColor)
  final public var pagesCount: Swift.Int {
    get
    set
  }
  final public func setPage(_ pageValue: CoreFoundation.CGFloat)
  @objc override final public func calculateSizeThatFits(_ constrainedSize: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  @objc override final public func layout()
  @objc deinit
}
public class ActionSheetSwitchItem : Display.ActionSheetItem {
  final public let title: Swift.String
  final public let isOn: Swift.Bool
  final public let action: (Swift.Bool) -> Swift.Void
  public init(title: Swift.String, isOn: Swift.Bool, action: @escaping (Swift.Bool) -> Swift.Void)
  public func node(theme: Display.ActionSheetControllerTheme) -> Display.ActionSheetItemNode
  public func updateNode(_ node: Display.ActionSheetItemNode)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class ActionSheetSwitchNode : Display.ActionSheetItemNode {
  override public init(theme: Display.ActionSheetControllerTheme)
  override public func updateLayout(constrainedSize: CoreFoundation.CGSize, transition: Display.ContainedViewLayoutTransition) -> CoreFoundation.CGSize
  @objc deinit
}
public enum ContextGestureTransition {
  case begin
  case update
  case ended(CoreFoundation.CGFloat)
}
public func cancelParentGestures(view: UIKit.UIView, ignore: [UIKit.UIGestureRecognizer] = [])
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class ContextGesture : UIKit.UIGestureRecognizer, UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor(unsafe) final public var beginDelay: Swift.Double
  @_Concurrency.MainActor(unsafe) final public var activateOnTap: Swift.Bool
  @_Concurrency.MainActor(unsafe) final public var shouldBegin: ((CoreFoundation.CGPoint) -> Swift.Bool)?
  @_Concurrency.MainActor(unsafe) final public var activationProgress: ((CoreFoundation.CGFloat, Display.ContextGestureTransition) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var activated: ((Display.ContextGesture, CoreFoundation.CGPoint) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var externalUpdated: ((UIKit.UIView?, CoreFoundation.CGPoint) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var externalEnded: (((UIKit.UIView?, CoreFoundation.CGPoint)?) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var activatedAfterCompletion: ((CoreFoundation.CGPoint, Swift.Bool) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var cancelGesturesOnActivation: (() -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(target: Any?, action: ObjectiveC.Selector?)
  @_Concurrency.MainActor(unsafe) @objc override final public func reset()
  @_Concurrency.MainActor(unsafe) @objc final public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesMoved(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesCancelled(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) final public func cancel()
  @_Concurrency.MainActor(unsafe) final public func endPressedAppearance()
  @objc deinit
}
public struct ContainerViewLayoutInsetOptions : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  public init()
  public static let statusBar: Display.ContainerViewLayoutInsetOptions
  public static let input: Display.ContainerViewLayoutInsetOptions
  public typealias ArrayLiteralElement = Display.ContainerViewLayoutInsetOptions
  public typealias Element = Display.ContainerViewLayoutInsetOptions
  public typealias RawValue = Swift.Int
}
public enum ContainerViewLayoutSizeClass {
  case compact
  case regular
  public static func == (a: Display.ContainerViewLayoutSizeClass, b: Display.ContainerViewLayoutSizeClass) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct LayoutMetrics : Swift.Equatable {
  public let widthClass: Display.ContainerViewLayoutSizeClass
  public let heightClass: Display.ContainerViewLayoutSizeClass
  public init(widthClass: Display.ContainerViewLayoutSizeClass, heightClass: Display.ContainerViewLayoutSizeClass)
  public init()
  public static func == (a: Display.LayoutMetrics, b: Display.LayoutMetrics) -> Swift.Bool
}
public enum LayoutOrientation {
  case portrait
  case landscape
  public static func == (a: Display.LayoutOrientation, b: Display.LayoutOrientation) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ContainerViewLayout : Swift.Equatable {
  public var size: CoreFoundation.CGSize
  public var metrics: Display.LayoutMetrics
  public var deviceMetrics: Display.DeviceMetrics
  public var intrinsicInsets: UIKit.UIEdgeInsets
  public var safeInsets: UIKit.UIEdgeInsets
  public var additionalInsets: UIKit.UIEdgeInsets
  public var statusBarHeight: CoreFoundation.CGFloat?
  public var inputHeight: CoreFoundation.CGFloat?
  public var inputHeightIsInteractivellyChanging: Swift.Bool
  public var inVoiceOver: Swift.Bool
  public init(size: CoreFoundation.CGSize, metrics: Display.LayoutMetrics, deviceMetrics: Display.DeviceMetrics, intrinsicInsets: UIKit.UIEdgeInsets, safeInsets: UIKit.UIEdgeInsets, additionalInsets: UIKit.UIEdgeInsets, statusBarHeight: CoreFoundation.CGFloat?, inputHeight: CoreFoundation.CGFloat?, inputHeightIsInteractivellyChanging: Swift.Bool, inVoiceOver: Swift.Bool)
  public func addedInsets(insets: UIKit.UIEdgeInsets) -> Display.ContainerViewLayout
  public func withUpdatedSize(_ size: CoreFoundation.CGSize) -> Display.ContainerViewLayout
  public func withUpdatedIntrinsicInsets(_ intrinsicInsets: UIKit.UIEdgeInsets) -> Display.ContainerViewLayout
  public func withUpdatedInputHeight(_ inputHeight: CoreFoundation.CGFloat?) -> Display.ContainerViewLayout
  public func withUpdatedMetrics(_ metrics: Display.LayoutMetrics) -> Display.ContainerViewLayout
  public static func == (a: Display.ContainerViewLayout, b: Display.ContainerViewLayout) -> Swift.Bool
}
extension Display.ContainerViewLayout {
  public func insets(options: Display.ContainerViewLayoutInsetOptions) -> UIKit.UIEdgeInsets
  public var isModalOverlay: Swift.Bool {
    get
  }
  public var isNonExclusive: Swift.Bool {
    get
  }
  public var inSplitView: Swift.Bool {
    get
  }
  public var inSlideOver: Swift.Bool {
    get
  }
  public var orientation: Display.LayoutOrientation {
    get
  }
  public var standardKeyboardHeight: CoreFoundation.CGFloat {
    get
  }
  public var standardInputHeight: CoreFoundation.CGFloat {
    get
  }
}
@objc @_Concurrency.MainActor(unsafe) final public class ListViewReorderingGestureRecognizer : UIKit.UIGestureRecognizer {
  @_Concurrency.MainActor(unsafe) public init(shouldBegin: @escaping (CoreFoundation.CGPoint) -> (allowed: Swift.Bool, requiresLongPress: Swift.Bool, itemNode: Display.ListViewItemNode?), willBegin: @escaping (CoreFoundation.CGPoint) -> Swift.Void, began: @escaping (Display.ListViewItemNode) -> Swift.Void, ended: @escaping () -> Swift.Void, moved: @escaping (CoreFoundation.CGFloat) -> Swift.Void)
  @objc deinit
  @_Concurrency.MainActor(unsafe) @objc override final public func reset()
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesCancelled(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesMoved(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
}
public protocol SharedDisplayLinkDriverLink : AnyObject {
  var isPaused: Swift.Bool { get set }
  func invalidate()
}
@_hasMissingDesignatedInitializers final public class SharedDisplayLinkDriver {
  public typealias Link = Display.SharedDisplayLinkDriverLink
  public static let shared: Display.SharedDisplayLinkDriver
  @_hasMissingDesignatedInitializers final public class LinkImpl : Display.SharedDisplayLinkDriver.Link {
    final public let needsHighestFramerate: Swift.Bool
    final public var isPaused: Swift.Bool {
      get
      set
    }
    final public func invalidate()
    @objc deinit
  }
  @_hasMissingDesignatedInitializers final public class NativeLinkImpl : Display.SharedDisplayLinkDriver.Link {
    final public var isPaused: Swift.Bool {
      get
      set
    }
    @objc deinit
    final public func invalidate()
  }
  final public func updateForegroundState(_ isActive: Swift.Bool)
  final public func add(needsHighestFramerate: Swift.Bool = true, _ update: @escaping () -> Swift.Void) -> Display.SharedDisplayLinkDriver.Link
  @objc deinit
}
@objc final public class DisplayLinkTarget : ObjectiveC.NSObject {
  public init(_ f: @escaping () -> Swift.Void)
  @objc final public func event()
  @objc deinit
}
final public class DisplayLinkAnimator {
  public init(duration: Swift.Double, from fromValue: CoreFoundation.CGFloat, to toValue: CoreFoundation.CGFloat, update: @escaping (CoreFoundation.CGFloat) -> Swift.Void, completion: @escaping () -> Swift.Void)
  @objc deinit
  final public func invalidate()
}
final public class ConstantDisplayLinkAnimator {
  final public var frameInterval: Swift.Int {
    get
    set
  }
  final public var isPaused: Swift.Bool {
    get
    set
  }
  public init(update: @escaping () -> Swift.Void)
  @objc deinit
  final public func invalidate()
}
@objc open class ASImageNode : AsyncDisplayKit.ASDisplayNode {
  public var image: UIKit.UIImage? {
    get
    set
  }
  public var displayWithoutProcessing: Swift.Bool
  @objc override dynamic public init()
  @objc override dynamic open func didLoad()
  @objc override dynamic public func calculateSizeThatFits(_ contrainedSize: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  @objc deinit
}
public let kCAMediaTimingFunctionSpring: Swift.String
public let kCAMediaTimingFunctionCustomSpringPrefix: Swift.String
extension QuartzCore.CAAnimation {
  public var completion: ((Swift.Bool) -> Swift.Void)? {
    get
    set(value)
  }
}
extension QuartzCore.CALayer {
  public func makeAnimation(from: Swift.AnyObject?, to: Swift.AnyObject, keyPath: Swift.String, timingFunction: Swift.String, duration: Swift.Double, delay: Swift.Double = 0.0, mediaTimingFunction: QuartzCore.CAMediaTimingFunction? = nil, removeOnCompletion: Swift.Bool = true, additive: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil) -> QuartzCore.CAAnimation
  public func animate(from: Swift.AnyObject?, to: Swift.AnyObject, keyPath: Swift.String, timingFunction: Swift.String, duration: Swift.Double, delay: Swift.Double = 0.0, mediaTimingFunction: QuartzCore.CAMediaTimingFunction? = nil, removeOnCompletion: Swift.Bool = true, additive: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animateGroup(_ animations: [QuartzCore.CAAnimation], key: Swift.String, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animateKeyframes(values: [Swift.AnyObject], duration: Swift.Double, keyPath: Swift.String, timingFunction: Swift.String = CAMediaTimingFunctionName.linear.rawValue, mediaTimingFunction: QuartzCore.CAMediaTimingFunction? = nil, removeOnCompletion: Swift.Bool = true, additive: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func springAnimation(from: Swift.AnyObject, to: Swift.AnyObject, keyPath: Swift.String, duration: Swift.Double, delay: Swift.Double = 0.0, initialVelocity: CoreFoundation.CGFloat = 0.0, damping: CoreFoundation.CGFloat = 88.0, removeOnCompletion: Swift.Bool = true, additive: Swift.Bool = false) -> QuartzCore.CABasicAnimation
  public func animateSpring(from: Swift.AnyObject, to: Swift.AnyObject, keyPath: Swift.String, duration: Swift.Double, delay: Swift.Double = 0.0, initialVelocity: CoreFoundation.CGFloat = 0.0, damping: CoreFoundation.CGFloat = 88.0, removeOnCompletion: Swift.Bool = true, additive: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animateAdditive(from: Foundation.NSValue, to: Foundation.NSValue, keyPath: Swift.String, key: Swift.String, timingFunction: Swift.String, mediaTimingFunction: QuartzCore.CAMediaTimingFunction? = nil, duration: Swift.Double, removeOnCompletion: Swift.Bool = true, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animateAlpha(from: CoreFoundation.CGFloat, to: CoreFoundation.CGFloat, duration: Swift.Double, delay: Swift.Double = 0.0, timingFunction: Swift.String = CAMediaTimingFunctionName.easeInEaseOut.rawValue, mediaTimingFunction: QuartzCore.CAMediaTimingFunction? = nil, removeOnCompletion: Swift.Bool = true, completion: ((Swift.Bool) -> ())? = nil)
  public func animateScale(from: CoreFoundation.CGFloat, to: CoreFoundation.CGFloat, duration: Swift.Double, delay: Swift.Double = 0.0, timingFunction: Swift.String = CAMediaTimingFunctionName.easeInEaseOut.rawValue, mediaTimingFunction: QuartzCore.CAMediaTimingFunction? = nil, removeOnCompletion: Swift.Bool = true, additive: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animateScaleX(from: CoreFoundation.CGFloat, to: CoreFoundation.CGFloat, duration: Swift.Double, delay: Swift.Double = 0.0, timingFunction: Swift.String = CAMediaTimingFunctionName.easeInEaseOut.rawValue, mediaTimingFunction: QuartzCore.CAMediaTimingFunction? = nil, removeOnCompletion: Swift.Bool = true, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animateScaleY(from: CoreFoundation.CGFloat, to: CoreFoundation.CGFloat, duration: Swift.Double, delay: Swift.Double = 0.0, timingFunction: Swift.String = CAMediaTimingFunctionName.easeInEaseOut.rawValue, mediaTimingFunction: QuartzCore.CAMediaTimingFunction? = nil, removeOnCompletion: Swift.Bool = true, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animateRotation(from: CoreFoundation.CGFloat, to: CoreFoundation.CGFloat, duration: Swift.Double, delay: Swift.Double = 0.0, timingFunction: Swift.String = CAMediaTimingFunctionName.easeInEaseOut.rawValue, mediaTimingFunction: QuartzCore.CAMediaTimingFunction? = nil, removeOnCompletion: Swift.Bool = true, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animatePosition(from: CoreFoundation.CGPoint, to: CoreFoundation.CGPoint, duration: Swift.Double, delay: Swift.Double = 0.0, timingFunction: Swift.String = CAMediaTimingFunctionName.easeInEaseOut.rawValue, mediaTimingFunction: QuartzCore.CAMediaTimingFunction? = nil, removeOnCompletion: Swift.Bool = true, additive: Swift.Bool = false, force: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animateBounds(from: CoreFoundation.CGRect, to: CoreFoundation.CGRect, duration: Swift.Double, delay: Swift.Double = 0.0, timingFunction: Swift.String, mediaTimingFunction: QuartzCore.CAMediaTimingFunction? = nil, removeOnCompletion: Swift.Bool = true, additive: Swift.Bool = false, force: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animateWidth(from: CoreFoundation.CGFloat, to: CoreFoundation.CGFloat, duration: Swift.Double, delay: Swift.Double = 0.0, timingFunction: Swift.String, mediaTimingFunction: QuartzCore.CAMediaTimingFunction? = nil, removeOnCompletion: Swift.Bool = true, additive: Swift.Bool = false, force: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animateHeight(from: CoreFoundation.CGFloat, to: CoreFoundation.CGFloat, duration: Swift.Double, delay: Swift.Double = 0.0, timingFunction: Swift.String, mediaTimingFunction: QuartzCore.CAMediaTimingFunction? = nil, removeOnCompletion: Swift.Bool = true, additive: Swift.Bool = false, force: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animateBoundsOriginXAdditive(from: CoreFoundation.CGFloat, to: CoreFoundation.CGFloat, duration: Swift.Double, timingFunction: Swift.String = CAMediaTimingFunctionName.easeInEaseOut.rawValue, mediaTimingFunction: QuartzCore.CAMediaTimingFunction? = nil, removeOnCompletion: Swift.Bool = true, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animateBoundsOriginYAdditive(from: CoreFoundation.CGFloat, to: CoreFoundation.CGFloat, duration: Swift.Double, timingFunction: Swift.String = CAMediaTimingFunctionName.easeInEaseOut.rawValue, mediaTimingFunction: QuartzCore.CAMediaTimingFunction? = nil, removeOnCompletion: Swift.Bool = true, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animateBoundsOriginXAdditive(from: CoreFoundation.CGFloat, to: CoreFoundation.CGFloat, duration: Swift.Double, mediaTimingFunction: QuartzCore.CAMediaTimingFunction)
  public func animateBoundsOriginYAdditive(from: CoreFoundation.CGFloat, to: CoreFoundation.CGFloat, duration: Swift.Double, mediaTimingFunction: QuartzCore.CAMediaTimingFunction)
  public func animatePositionKeyframes(values: [CoreFoundation.CGPoint], duration: Swift.Double, removeOnCompletion: Swift.Bool = true, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animateFrame(from: CoreFoundation.CGRect, to: CoreFoundation.CGRect, duration: Swift.Double, delay: Swift.Double = 0.0, timingFunction: Swift.String = CAMediaTimingFunctionName.easeInEaseOut.rawValue, mediaTimingFunction: QuartzCore.CAMediaTimingFunction? = nil, removeOnCompletion: Swift.Bool = true, additive: Swift.Bool = false, force: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func cancelAnimationsRecursive(key: Swift.String)
}
public func isViewVisibleInHierarchy(_ view: UIKit.UIView, _ initial: Swift.Bool = true) -> Swift.Bool
@objc final public class HierarchyTrackingNode : AsyncDisplayKit.ASDisplayNode {
  public init(_ f: @escaping (Swift.Bool) -> Swift.Void)
  @objc override final public func didEnterHierarchy()
  @objc override final public func didExitHierarchy()
  @objc deinit
}
public func matchMinimumSystemVersion(major: Swift.Int, minor: Swift.Int = 0) -> Swift.Bool
@objc @_inheritsConvenienceInitializers open class GridItemNode : AsyncDisplayKit.ASDisplayNode {
  open var isVisibleInGrid: Swift.Bool
  open var isGridScrolling: Swift.Bool
  @objc override dynamic open var frame: CoreFoundation.CGRect {
    @objc get
    @objc set(value)
  }
  open func updateLayout(item: Display.GridItem, size: CoreFoundation.CGSize, isVisible: Swift.Bool, synchronousLoads: Swift.Bool)
  open func updateAbsoluteRect(_ absoluteRect: CoreFoundation.CGRect, within containerSize: CoreFoundation.CGSize)
  @objc override dynamic public init()
  @objc override dynamic public init(viewBlock: @escaping AsyncDisplayKit.ASDisplayNodeViewBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc override dynamic public init(layerBlock: @escaping AsyncDisplayKit.ASDisplayNodeLayerBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc deinit
}
public enum ContainedViewLayoutTransitionCurve : Swift.Equatable, Swift.Hashable {
  case linear
  case easeInOut
  case spring
  case customSpring(damping: CoreFoundation.CGFloat, initialVelocity: CoreFoundation.CGFloat)
  case custom(Swift.Float, Swift.Float, Swift.Float, Swift.Float)
  public static var slide: Display.ContainedViewLayoutTransitionCurve {
    get
  }
  public static func == (a: Display.ContainedViewLayoutTransitionCurve, b: Display.ContainedViewLayoutTransitionCurve) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Display.ContainedViewLayoutTransitionCurve {
  public func solve(at offset: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
}
extension Display.ContainedViewLayoutTransitionCurve {
  public var timingFunction: Swift.String {
    get
  }
  public var mediaTimingFunction: QuartzCore.CAMediaTimingFunction? {
    get
  }
  public var viewAnimationOptions: UIKit.UIView.AnimationOptions {
    get
  }
}
public enum ContainedViewLayoutTransition {
  case immediate
  case animated(duration: Swift.Double, curve: Display.ContainedViewLayoutTransitionCurve)
  public var isAnimated: Swift.Bool {
    get
  }
}
extension CoreFoundation.CGRect {
  public var ensuredValid: CoreFoundation.CGRect {
    get
  }
}
extension Display.ContainedViewLayoutTransition {
  public func animation() -> QuartzCore.CABasicAnimation?
  public func updateFrame(node: AsyncDisplayKit.ASDisplayNode, frame: CoreFoundation.CGRect, force: Swift.Bool = false, beginWithCurrentState: Swift.Bool = false, delay: Swift.Double = 0.0, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateFrameAsPositionAndBounds(node: AsyncDisplayKit.ASDisplayNode, frame: CoreFoundation.CGRect, force: Swift.Bool = false, beginWithCurrentState: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateFrameAsPositionAndBounds(layer: QuartzCore.CALayer, frame: CoreFoundation.CGRect, force: Swift.Bool = false, beginWithCurrentState: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateFrameAdditive(node: AsyncDisplayKit.ASDisplayNode, frame: CoreFoundation.CGRect, force: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateFrameAdditive(view: UIKit.UIView, frame: CoreFoundation.CGRect, force: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateFrameAdditiveToCenter(node: AsyncDisplayKit.ASDisplayNode, frame: CoreFoundation.CGRect, force: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateFrameAdditiveToCenter(view: UIKit.UIView, frame: CoreFoundation.CGRect, force: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateBounds(node: AsyncDisplayKit.ASDisplayNode, bounds: CoreFoundation.CGRect, force: Swift.Bool = false, beginWithCurrentState: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateBounds(layer: QuartzCore.CALayer, bounds: CoreFoundation.CGRect, force: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updatePosition(node: AsyncDisplayKit.ASDisplayNode, position: CoreFoundation.CGPoint, beginWithCurrentState: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updatePosition(layer: QuartzCore.CALayer, position: CoreFoundation.CGPoint, force: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animatePosition(layer: QuartzCore.CALayer, from fromValue: CoreFoundation.CGPoint, to toValue: CoreFoundation.CGPoint, removeOnCompletion: Swift.Bool = true, additive: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animatePosition(node: AsyncDisplayKit.ASDisplayNode, from position: CoreFoundation.CGPoint, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animatePosition(node: AsyncDisplayKit.ASDisplayNode, to position: CoreFoundation.CGPoint, removeOnCompletion: Swift.Bool = true, additive: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animatePositionWithKeyframes(node: AsyncDisplayKit.ASDisplayNode, keyframes: [CoreFoundation.CGPoint], removeOnCompletion: Swift.Bool = true, additive: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animatePositionWithKeyframes(layer: QuartzCore.CALayer, keyframes: [CoreFoundation.CGPoint], removeOnCompletion: Swift.Bool = true, additive: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animateFrame(node: AsyncDisplayKit.ASDisplayNode, from frame: CoreFoundation.CGRect, to toFrame: CoreFoundation.CGRect? = nil, removeOnCompletion: Swift.Bool = true, additive: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animateFrame(layer: QuartzCore.CALayer, from frame: CoreFoundation.CGRect, to toFrame: CoreFoundation.CGRect? = nil, removeOnCompletion: Swift.Bool = true, additive: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animateBounds(layer: QuartzCore.CALayer, from bounds: CoreFoundation.CGRect, removeOnCompletion: Swift.Bool = true, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animateWidthAdditive(layer: QuartzCore.CALayer, value: CoreFoundation.CGFloat, removeOnCompletion: Swift.Bool = true, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animateHeightAdditive(layer: QuartzCore.CALayer, value: CoreFoundation.CGFloat, removeOnCompletion: Swift.Bool = true, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animateOffsetAdditive(node: AsyncDisplayKit.ASDisplayNode, offset: CoreFoundation.CGFloat)
  public func animateHorizontalOffsetAdditive(node: AsyncDisplayKit.ASDisplayNode, offset: CoreFoundation.CGFloat, completion: (() -> Swift.Void)? = nil)
  public func animateHorizontalOffsetAdditive(layer: QuartzCore.CALayer, offset: CoreFoundation.CGFloat, completion: (() -> Swift.Void)? = nil)
  public func animateOffsetAdditive(layer: QuartzCore.CALayer, offset: CoreFoundation.CGFloat, completion: (() -> Swift.Void)? = nil)
  public func animatePositionAdditive(node: AsyncDisplayKit.ASDisplayNode, offset: CoreFoundation.CGFloat, removeOnCompletion: Swift.Bool = true, completion: @escaping (Swift.Bool) -> Swift.Void)
  public func animatePositionAdditive(layer: QuartzCore.CALayer, offset: CoreFoundation.CGFloat, delay: Swift.Double = 0.0, removeOnCompletion: Swift.Bool = true, completion: @escaping (Swift.Bool) -> Swift.Void)
  public func animatePositionAdditive(node: AsyncDisplayKit.ASDisplayNode, offset: CoreFoundation.CGPoint, delay: Swift.Double = 0.0, removeOnCompletion: Swift.Bool = true, completion: (() -> Swift.Void)? = nil)
  public func animatePositionAdditive(layer: QuartzCore.CALayer, offset: CoreFoundation.CGPoint, to toOffset: CoreFoundation.CGPoint = CGPoint(), removeOnCompletion: Swift.Bool = true, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animateContentsRectPositionAdditive(layer: QuartzCore.CALayer, offset: CoreFoundation.CGPoint, removeOnCompletion: Swift.Bool = true, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateFrame(view: UIKit.UIView, frame: CoreFoundation.CGRect, force: Swift.Bool = false, beginWithCurrentState: Swift.Bool = false, delay: Swift.Double = 0.0, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateFrame(layer: QuartzCore.CALayer, frame: CoreFoundation.CGRect, beginWithCurrentState: Swift.Bool = false, delay: Swift.Double = 0.0, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateAlpha(node: AsyncDisplayKit.ASDisplayNode, alpha: CoreFoundation.CGFloat, beginWithCurrentState: Swift.Bool = false, force: Swift.Bool = false, delay: Swift.Double = 0.0, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateAlpha(layer: QuartzCore.CALayer, alpha: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateBackgroundColor(node: AsyncDisplayKit.ASDisplayNode, color: UIKit.UIColor, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateBackgroundColor(layer: QuartzCore.CALayer, color: UIKit.UIColor, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateCornerRadius(node: AsyncDisplayKit.ASDisplayNode, cornerRadius: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateCornerRadius(layer: QuartzCore.CALayer, cornerRadius: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateContentsRect(layer: QuartzCore.CALayer, contentsRect: CoreFoundation.CGRect, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animateTransformScale(node: AsyncDisplayKit.ASDisplayNode, from fromScale: CoreFoundation.CGFloat, additive: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animateTransformScale(node: AsyncDisplayKit.ASDisplayNode, from fromScale: CoreFoundation.CGPoint, delay: Swift.Double = 0.0, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animateTransformScale(layer: QuartzCore.CALayer, from fromScale: CoreFoundation.CGPoint, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animateTransformScale(layer: QuartzCore.CALayer, from fromScale: CoreFoundation.CGPoint, to toScale: CoreFoundation.CGPoint, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animateTransformScale(view: UIKit.UIView, from fromScale: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateTransform(node: AsyncDisplayKit.ASDisplayNode, transform: CoreFoundation.CGAffineTransform, beginWithCurrentState: Swift.Bool = false, delay: Swift.Double = 0.0, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateTransformScale(node: AsyncDisplayKit.ASDisplayNode, scale: CoreFoundation.CGFloat, beginWithCurrentState: Swift.Bool = false, delay: Swift.Double = 0.0, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateTransformScale(layer: QuartzCore.CALayer, scale: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateSublayerTransformScale(node: AsyncDisplayKit.ASDisplayNode, scale: CoreFoundation.CGFloat, delay: Swift.Double = 0.0, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateSublayerTransformScaleAdditive(node: AsyncDisplayKit.ASDisplayNode, scale: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateSublayerTransformScaleAndOffset(node: AsyncDisplayKit.ASDisplayNode, scale: CoreFoundation.CGFloat, offset: CoreFoundation.CGPoint, beginWithCurrentState: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateSublayerTransformScale(node: AsyncDisplayKit.ASDisplayNode, scale: CoreFoundation.CGPoint, beginWithCurrentState: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateSublayerTransformScale(layer: QuartzCore.CALayer, scale: CoreFoundation.CGPoint, beginWithCurrentState: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateTransformScale(node: AsyncDisplayKit.ASDisplayNode, scale: CoreFoundation.CGPoint, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateTransformScale(layer: QuartzCore.CALayer, scale: CoreFoundation.CGPoint, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateSublayerTransformOffset(layer: QuartzCore.CALayer, offset: CoreFoundation.CGPoint, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateTransformRotation(node: AsyncDisplayKit.ASDisplayNode, angle: CoreFoundation.CGFloat, beginWithCurrentState: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateTransformRotation(view: UIKit.UIView, angle: CoreFoundation.CGFloat, beginWithCurrentState: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateTransformRotationAndScale(view: UIKit.UIView, angle: CoreFoundation.CGFloat, scale: CoreFoundation.CGPoint, beginWithCurrentState: Swift.Bool = false, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updatePath(layer: QuartzCore.CAShapeLayer, path: CoreGraphics.CGPath, delay: Swift.Double = 0.0, completion: ((Swift.Bool) -> Swift.Void)? = nil)
}
public struct CombinedTransition {
  public var horizontal: Display.ContainedViewLayoutTransition
  public var vertical: Display.ContainedViewLayoutTransition
  public var isAnimated: Swift.Bool {
    get
  }
  public init(horizontal: Display.ContainedViewLayoutTransition, vertical: Display.ContainedViewLayoutTransition)
  public func animateFrame(layer: QuartzCore.CALayer, from fromFrame: CoreFoundation.CGRect, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateFrame(layer: QuartzCore.CALayer, frame: CoreFoundation.CGRect, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updateFrame(node: AsyncDisplayKit.ASDisplayNode, frame: CoreFoundation.CGRect, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func updatePosition(layer: QuartzCore.CALayer, position: CoreFoundation.CGPoint, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func animatePositionAdditive(layer: QuartzCore.CALayer, offset: CoreFoundation.CGPoint, to toOffset: CoreFoundation.CGPoint = CGPoint(), removeOnCompletion: Swift.Bool = true, completion: ((Swift.Bool) -> Swift.Void)? = nil)
}
extension Display.ContainedViewLayoutTransition {
  public func animateView(allowUserInteraction: Swift.Bool = false, delay: Swift.Double = 0.0, _ f: @escaping () -> Swift.Void, completion: ((Swift.Bool) -> Swift.Void)? = nil)
}
public protocol ControlledTransitionAnimator : AnyObject {
  var duration: Swift.Double { get }
  func startAnimation()
  func setAnimationProgress(_ progress: CoreFoundation.CGFloat)
  func finishAnimation()
  func updateAlpha(layer: QuartzCore.CALayer, alpha: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)?)
  func updateScale(layer: QuartzCore.CALayer, scale: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)?)
  func animateScale(layer: QuartzCore.CALayer, from fromValue: CoreFoundation.CGFloat, to toValue: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)?)
  func updatePosition(layer: QuartzCore.CALayer, position: CoreFoundation.CGPoint, completion: ((Swift.Bool) -> Swift.Void)?)
  func animatePosition(layer: QuartzCore.CALayer, from fromValue: CoreFoundation.CGPoint, to toValue: CoreFoundation.CGPoint, completion: ((Swift.Bool) -> Swift.Void)?)
  func updateBounds(layer: QuartzCore.CALayer, bounds: CoreFoundation.CGRect, completion: ((Swift.Bool) -> Swift.Void)?)
  func updateFrame(layer: QuartzCore.CALayer, frame: CoreFoundation.CGRect, completion: ((Swift.Bool) -> Swift.Void)?)
  func updateCornerRadius(layer: QuartzCore.CALayer, cornerRadius: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)?)
  func updateContentsRect(layer: QuartzCore.CALayer, contentsRect: CoreFoundation.CGRect, completion: ((Swift.Bool) -> Swift.Void)?)
}
final public class ControlledTransition {
  @_hasMissingDesignatedInitializers final public class NativeAnimator : Display.ControlledTransitionAnimator {
    final public let duration: Swift.Double
    final public func startAnimation()
    final public func setAnimationProgress(_ progress: CoreFoundation.CGFloat)
    final public func finishAnimation()
    final public func updateAlpha(layer: QuartzCore.CALayer, alpha: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)?)
    final public func updateScale(layer: QuartzCore.CALayer, scale: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)?)
    final public func animateScale(layer: QuartzCore.CALayer, from fromValue: CoreFoundation.CGFloat, to toValue: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)?)
    final public func animatePosition(layer: QuartzCore.CALayer, from fromValue: CoreFoundation.CGPoint, to toValue: CoreFoundation.CGPoint, completion: ((Swift.Bool) -> Swift.Void)?)
    final public func updatePosition(layer: QuartzCore.CALayer, position: CoreFoundation.CGPoint, completion: ((Swift.Bool) -> Swift.Void)?)
    final public func updateBounds(layer: QuartzCore.CALayer, bounds: CoreFoundation.CGRect, completion: ((Swift.Bool) -> Swift.Void)?)
    final public func updateFrame(layer: QuartzCore.CALayer, frame: CoreFoundation.CGRect, completion: ((Swift.Bool) -> Swift.Void)?)
    final public func updateCornerRadius(layer: QuartzCore.CALayer, cornerRadius: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)?)
    final public func updateContentsRect(layer: QuartzCore.CALayer, contentsRect: CoreFoundation.CGRect, completion: ((Swift.Bool) -> Swift.Void)?)
    @objc deinit
  }
  @_hasMissingDesignatedInitializers final public class LegacyAnimator : Display.ControlledTransitionAnimator {
    final public let duration: Swift.Double
    final public let transition: Display.ContainedViewLayoutTransition
    final public func startAnimation()
    final public func setAnimationProgress(_ progress: CoreFoundation.CGFloat)
    final public func finishAnimation()
    final public func updateAlpha(layer: QuartzCore.CALayer, alpha: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)?)
    final public func updateScale(layer: QuartzCore.CALayer, scale: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)?)
    final public func animateScale(layer: QuartzCore.CALayer, from fromValue: CoreFoundation.CGFloat, to toValue: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)?)
    final public func updatePosition(layer: QuartzCore.CALayer, position: CoreFoundation.CGPoint, completion: ((Swift.Bool) -> Swift.Void)?)
    final public func animatePosition(layer: QuartzCore.CALayer, from fromValue: CoreFoundation.CGPoint, to toValue: CoreFoundation.CGPoint, completion: ((Swift.Bool) -> Swift.Void)?)
    final public func updateBounds(layer: QuartzCore.CALayer, bounds: CoreFoundation.CGRect, completion: ((Swift.Bool) -> Swift.Void)?)
    final public func updateFrame(layer: QuartzCore.CALayer, frame: CoreFoundation.CGRect, completion: ((Swift.Bool) -> Swift.Void)?)
    final public func updateCornerRadius(layer: QuartzCore.CALayer, cornerRadius: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)?)
    final public func updateContentsRect(layer: QuartzCore.CALayer, contentsRect: CoreFoundation.CGRect, completion: ((Swift.Bool) -> Swift.Void)?)
    @objc deinit
  }
  final public let animator: Display.ControlledTransitionAnimator
  final public let legacyAnimator: Display.ControlledTransition.LegacyAnimator
  public init(duration: Swift.Double, curve: Display.ContainedViewLayoutTransitionCurve, interactive: Swift.Bool)
  final public func merge(with other: Display.ControlledTransition, forceRestart: Swift.Bool)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class ListViewBackingView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) weak final public var target: Display.ListView? {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public class var layerClass: Swift.AnyClass {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public func setNeedsLayout()
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override final public func setNeedsDisplay()
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesCancelled(_ touches: Swift.Set<UIKit.UITouch>?, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesMoved(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override final public func hitTest(_ point: CoreFoundation.CGPoint, with event: UIKit.UIEvent?) -> UIKit.UIView?
  @_Concurrency.MainActor(unsafe) @objc override final public func accessibilityScroll(_ direction: UIKit.UIAccessibilityScrollDirection) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public enum ListViewVisibleContentOffset {
  case known(CoreFoundation.CGFloat)
  case unknown
  case none
}
public enum ListViewScrollDirection {
  case up
  case down
  public static func == (a: Display.ListViewScrollDirection, b: Display.ListViewScrollDirection) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ListViewKeepTopItemOverscrollBackground {
  public let color: UIKit.UIColor
  public let direction: Swift.Bool
  public init(color: UIKit.UIColor, direction: Swift.Bool)
}
public enum GeneralScrollDirection {
  case up
  case down
  public static func == (a: Display.GeneralScrollDirection, b: Display.GeneralScrollDirection) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_Concurrency.MainActor(unsafe) open class ListView : AsyncDisplayKit.ASDisplayNode, UIKit.UIScrollViewAccessibilityDelegate, UIKit.UIGestureRecognizerDelegate {
  public struct ScrollingIndicatorState {
    public struct Item {
      public var index: Swift.Int
      public var offset: CoreFoundation.CGFloat
      public var height: CoreFoundation.CGFloat
      public init(index: Swift.Int, offset: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat)
    }
    public var insets: UIKit.UIEdgeInsets
    public var topItem: Display.ListView.ScrollingIndicatorState.Item
    public var bottomItem: Display.ListView.ScrollingIndicatorState.Item
    public var itemCount: Swift.Int
    public init(insets: UIKit.UIEdgeInsets, topItem: Display.ListView.ScrollingIndicatorState.Item, bottomItem: Display.ListView.ScrollingIndicatorState.Item, itemCount: Swift.Int)
  }
  @_Concurrency.MainActor(unsafe) final public let scroller: Display.ListViewScroller
  @_Concurrency.MainActor(unsafe) final public var visibleSize: CoreFoundation.CGSize {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var insets: UIKit.UIEdgeInsets {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var visualInsets: UIKit.UIEdgeInsets?
  @_Concurrency.MainActor(unsafe) final public var headerInsets: UIKit.UIEdgeInsets {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var scrollIndicatorInsets: UIKit.UIEdgeInsets {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var dynamicBounceEnabled: Swift.Bool
  @_Concurrency.MainActor(unsafe) final public var rotated: Swift.Bool
  @_Concurrency.MainActor(unsafe) final public var experimentalSnapScrollToItem: Swift.Bool
  @_Concurrency.MainActor(unsafe) final public var scrollEnabled: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var preloadPages: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var keepMinimalScrollHeightWithTopInset: CoreFoundation.CGFloat?
  @_Concurrency.MainActor(unsafe) final public var itemNodeHitTest: ((CoreFoundation.CGPoint) -> Swift.Bool)?
  @_Concurrency.MainActor(unsafe) final public var stackFromBottom: Swift.Bool
  @_Concurrency.MainActor(unsafe) final public var stackFromBottomInsetItemFactor: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) final public var limitHitTestToNodes: Swift.Bool
  @_Concurrency.MainActor(unsafe) final public var keepTopItemOverscrollBackground: Display.ListViewKeepTopItemOverscrollBackground? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var keepBottomItemOverscrollBackground: UIKit.UIColor? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var snapToBottomInsetUntilFirstInteraction: Swift.Bool
  @_Concurrency.MainActor(unsafe) final public var updateFloatingHeaderOffset: ((CoreFoundation.CGFloat, Display.ContainedViewLayoutTransition) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var didScrollWithOffset: ((CoreFoundation.CGFloat, Display.ContainedViewLayoutTransition, Display.ListViewItemNode?, Swift.Bool) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var addContentOffset: ((CoreFoundation.CGFloat, Display.ListViewItemNode?) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var updateScrollingIndicator: ((Display.ListView.ScrollingIndicatorState?, Display.ContainedViewLayoutTransition) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) public var verticalScrollIndicatorColor: UIKit.UIColor? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var verticalScrollIndicatorFollowsOverscroll: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var isTracking: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) public var trackingOffset: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor(unsafe) public var beganTrackingAtTopOrigin: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) public var isDragging: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) public var isDeceleratingAfterTracking: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var synchronousNodes: Swift.Bool
  @_Concurrency.MainActor(unsafe) final public var debugInfo: Swift.Bool
  @_Concurrency.MainActor(unsafe) final public var useSingleDimensionTouchPoint: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var enableExtractedBackgrounds: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var itemHeaderNodesAlpha: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) final public var displayedItemRangeChanged: (Display.ListViewDisplayedItemRange, Any?) -> Swift.Void
  @_Concurrency.MainActor(unsafe) final public var displayedItemRange: Display.ListViewDisplayedItemRange {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var internalDisplayedItemRange: Display.ListViewDisplayedItemRange? {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var opaqueTransactionState: Any? {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var visibleContentOffsetChanged: (Display.ListViewVisibleContentOffset) -> Swift.Void
  @_Concurrency.MainActor(unsafe) final public var visibleBottomContentOffsetChanged: (Display.ListViewVisibleContentOffset) -> Swift.Void
  @_Concurrency.MainActor(unsafe) final public var beganInteractiveDragging: (CoreFoundation.CGPoint) -> Swift.Void
  @_Concurrency.MainActor(unsafe) final public var endedInteractiveDragging: (CoreFoundation.CGPoint) -> Swift.Void
  @_Concurrency.MainActor(unsafe) final public var didEndScrolling: ((Swift.Bool) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var generalScrollDirectionUpdated: (Display.GeneralScrollDirection) -> Swift.Void
  @_Concurrency.MainActor(unsafe) public var isReordering: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var willBeginReorder: (CoreFoundation.CGPoint) -> Swift.Void
  @_Concurrency.MainActor(unsafe) final public var reorderBegan: () -> Swift.Void
  @_Concurrency.MainActor(unsafe) final public var reorderItem: (Swift.Int, Swift.Int, Any?) -> SwiftSignalKit.Signal<Swift.Bool, SwiftSignalKit.NoError>
  @_Concurrency.MainActor(unsafe) final public var reorderCompleted: (Any?) -> Swift.Void
  @_Concurrency.MainActor(unsafe) final public var tapped: (() -> Swift.Void)? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var reorderedItemHasShadow: Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init()
  @objc deinit
  @_Concurrency.MainActor(unsafe) public func flashHeaderItems(duration: Swift.Double = 2.0)
  @_Concurrency.MainActor(unsafe) @objc public func scrollViewWillBeginDragging(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc public func scrollViewDidEndDragging(_ scrollView: UIKit.UIScrollView, willDecelerate decelerate: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc public func scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) public func transferVelocity(_ velocity: CoreFoundation.CGFloat)
  @_Concurrency.MainActor(unsafe) public var defaultToSynchronousTransactionWhileScrolling: Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc public func scrollViewDidScroll(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) public func visibleContentOffset() -> Display.ListViewVisibleContentOffset
  @_Concurrency.MainActor(unsafe) public func visibleBottomContentOffset() -> Display.ListViewVisibleContentOffset
  @_Concurrency.MainActor(unsafe) public func transaction(deleteIndices: [Display.ListViewDeleteItem], insertIndicesAndItems: [Display.ListViewInsertItem], updateIndicesAndItems: [Display.ListViewUpdateItem], options: Display.ListViewDeleteAndInsertOptions, scrollToItem: Display.ListViewScrollToItem? = nil, additionalScrollDistance: CoreFoundation.CGFloat = 0.0, updateSizeAndInsets: Display.ListViewUpdateSizeAndInsets? = nil, stationaryItemRange: (Swift.Int, Swift.Int)? = nil, updateOpaqueState: Any?, completion: @escaping (Display.ListViewDisplayedItemRange) -> Swift.Void = { _ in })
  @_Concurrency.MainActor(unsafe) public func updateVisibleItemRange(force: Swift.Bool = false)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) public func clearHighlightAnimated(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public func updateNodeHighlightsAnimated(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public func itemIndexAtPoint(_ point: CoreFoundation.CGPoint) -> Swift.Int?
  @_Concurrency.MainActor(unsafe) public func itemNodeAtIndex(_ index: Swift.Int) -> Display.ListViewItemNode?
  @_Concurrency.MainActor(unsafe) public func indexOf(itemNode: Display.ListViewItemNode) -> Swift.Int?
  @_Concurrency.MainActor(unsafe) public func forEachItemNode(_ f: (AsyncDisplayKit.ASDisplayNode) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) public func enumerateItemNodes(_ f: (AsyncDisplayKit.ASDisplayNode) -> Swift.Bool)
  @_Concurrency.MainActor(unsafe) public func forEachVisibleItemNode(_ f: (AsyncDisplayKit.ASDisplayNode) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) public func forEachItemHeaderNode(_ f: (Display.ListViewItemHeaderNode) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) public func forEachAccessoryItemNode(_ f: (Display.ListViewAccessoryItemNode) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) public func ensureItemNodeVisible(_ node: Display.ListViewItemNode, animated: Swift.Bool = true, overflow: CoreFoundation.CGFloat = 0.0, allowIntersection: Swift.Bool = false, atTop: Swift.Bool = false, curve: Display.ListViewAnimationCurve = .Default(duration: 0.25))
  @_Concurrency.MainActor(unsafe) public func ensureItemNodeVisibleAtTopInset(_ node: Display.ListViewItemNode)
  @_Concurrency.MainActor(unsafe) public func itemNodeRelativeOffset(_ node: Display.ListViewItemNode) -> CoreFoundation.CGFloat?
  @_Concurrency.MainActor(unsafe) public func itemNodeVisibleInsideInsets(_ node: Display.ListViewItemNode) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func touchesMoved(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) public func cancelSelection()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func touchesCancelled(_ touches: Swift.Set<UIKit.UITouch>?, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) public func withTransaction(_ f: @escaping () -> Swift.Void)
  @_Concurrency.MainActor(unsafe) public func scrollToOffsetFromTop(_ offset: CoreFoundation.CGFloat, animated: Swift.Bool) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) public var accessibilityPageScrolledString: ((Swift.String, Swift.String) -> Swift.String)?
  @_Concurrency.MainActor(unsafe) public func scrollWithDirection(_ direction: Display.ListViewScrollDirection, distance: CoreFoundation.CGFloat) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func accessibilityScroll(_ direction: UIKit.UIAccessibilityScrollDirection) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class WindowCoveringView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) open func updateLayout(_ size: CoreFoundation.CGSize)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public static func animationDurationFactor() -> Swift.Double
}
public func makeSpringAnimation(_ keyPath: Swift.String) -> QuartzCore.CABasicAnimation
public func makeSpringBounceAnimation(_ keyPath: Swift.String, _ initialVelocity: CoreFoundation.CGFloat, _ damping: CoreFoundation.CGFloat) -> QuartzCore.CABasicAnimation
public func springAnimationValueAt(_ animation: QuartzCore.CABasicAnimation, _ t: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
public func makeCustomZoomBlurEffect(isLight: Swift.Bool) -> UIKit.UIBlurEffect?
public func applySmoothRoundedCorners(_ layer: QuartzCore.CALayer)
public func dumpViews(_ view: UIKit.UIView)
public func dumpLayers(_ layer: QuartzCore.CALayer)
public let UIScreenScale: CoreFoundation.CGFloat
public func floorToScreenPixels(_ value: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
public func ceilToScreenPixels(_ value: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
public let UIScreenPixel: CoreFoundation.CGFloat
extension UIKit.UIColor {
  convenience public init(rgb: Swift.UInt32)
  convenience public init(rgb: Swift.UInt32, alpha: CoreFoundation.CGFloat)
  convenience public init(argb: Swift.UInt32)
  convenience public init?(hexString: Swift.String)
  public var alpha: CoreFoundation.CGFloat {
    get
  }
  public var rgb: Swift.UInt32 {
    get
  }
  public var argb: Swift.UInt32 {
    get
  }
  public var hsb: (h: CoreFoundation.CGFloat, s: CoreFoundation.CGFloat, b: CoreFoundation.CGFloat) {
    get
  }
  public var lightness: CoreFoundation.CGFloat {
    get
  }
  public func withMultipliedBrightnessBy(_ factor: CoreFoundation.CGFloat) -> UIKit.UIColor
  public func withMultiplied(hue: CoreFoundation.CGFloat, saturation: CoreFoundation.CGFloat, brightness: CoreFoundation.CGFloat) -> UIKit.UIColor
  public func mixedWith(_ other: UIKit.UIColor, alpha: CoreFoundation.CGFloat) -> UIKit.UIColor
  public func blitOver(_ other: UIKit.UIColor, alpha: CoreFoundation.CGFloat) -> UIKit.UIColor
  public func withMultipliedAlpha(_ alpha: CoreFoundation.CGFloat) -> UIKit.UIColor
  public func interpolateTo(_ color: UIKit.UIColor, fraction: CoreFoundation.CGFloat) -> UIKit.UIColor?
  public func distance(to other: UIKit.UIColor) -> Swift.Int32
  public static func average(of colors: [UIKit.UIColor]) -> UIKit.UIColor
}
extension CoreFoundation.CGSize {
  public func fitted(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public func cropped(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public func fittedToArea(_ area: CoreFoundation.CGFloat) -> CoreFoundation.CGSize
  public func aspectFilled(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public func aspectFitted(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public func aspectFittedOrSmaller(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public func aspectFittedWithOverflow(_ size: CoreFoundation.CGSize, leeway: CoreFoundation.CGFloat) -> CoreFoundation.CGSize
  public func fittedToWidthOrSmaller(_ width: CoreFoundation.CGFloat) -> CoreFoundation.CGSize
  public func multipliedByScreenScale() -> CoreFoundation.CGSize
  public func dividedByScreenScale() -> CoreFoundation.CGSize
  public var integralFloor: CoreFoundation.CGSize {
    get
  }
}
public func assertNotOnMainThread(_ file: Swift.String = #file, line: Swift.Int = #line)
extension UIKit.UIImage {
  public func precomposed() -> UIKit.UIImage
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func snapshotContentTree(unhide: Swift.Bool = false, keepTransform: Swift.Bool = false) -> UIKit.UIView?
}
extension QuartzCore.CALayer {
  public func snapshotContentTree(unhide: Swift.Bool = false) -> QuartzCore.CALayer?
}
extension QuartzCore.CALayer {
  public var layerTintColor: CoreGraphics.CGColor? {
    get
    set(value)
  }
}
extension QuartzCore.CALayer {
  public func snapshotContentTreeAsView(unhide: Swift.Bool = false) -> UIKit.UIView?
}
extension CoreFoundation.CGRect {
  public var topLeft: CoreFoundation.CGPoint {
    get
  }
  public var topRight: CoreFoundation.CGPoint {
    get
  }
  public var bottomLeft: CoreFoundation.CGPoint {
    get
  }
  public var bottomRight: CoreFoundation.CGPoint {
    get
  }
}
extension CoreFoundation.CGPoint {
  public func offsetBy(dx: CoreFoundation.CGFloat, dy: CoreFoundation.CGFloat) -> CoreFoundation.CGPoint
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class ListViewScroller : UIKit.UIScrollView, UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc final public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override final public func gestureRecognizerShouldBegin(_ gestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesShouldCancel(in view: UIKit.UIView) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override final public var isDecelerating: Swift.Bool {
    @objc get
  }
  @objc deinit
}
public enum AlertControllerThemeBackgroundType {
  case light
  case dark
  public static func == (a: Display.AlertControllerThemeBackgroundType, b: Display.AlertControllerThemeBackgroundType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class AlertControllerTheme : Swift.Equatable {
  final public let backgroundType: Display.ActionSheetControllerThemeBackgroundType
  final public let backgroundColor: UIKit.UIColor
  final public let separatorColor: UIKit.UIColor
  final public let highlightedItemColor: UIKit.UIColor
  final public let primaryColor: UIKit.UIColor
  final public let secondaryColor: UIKit.UIColor
  final public let accentColor: UIKit.UIColor
  final public let contrastColor: UIKit.UIColor
  final public let destructiveColor: UIKit.UIColor
  final public let disabledColor: UIKit.UIColor
  final public let controlBorderColor: UIKit.UIColor
  final public let baseFontSize: CoreFoundation.CGFloat
  public init(backgroundType: Display.ActionSheetControllerThemeBackgroundType, backgroundColor: UIKit.UIColor, separatorColor: UIKit.UIColor, highlightedItemColor: UIKit.UIColor, primaryColor: UIKit.UIColor, secondaryColor: UIKit.UIColor, accentColor: UIKit.UIColor, contrastColor: UIKit.UIColor, destructiveColor: UIKit.UIColor, disabledColor: UIKit.UIColor, controlBorderColor: UIKit.UIColor, baseFontSize: CoreFoundation.CGFloat)
  public static func == (lhs: Display.AlertControllerTheme, rhs: Display.AlertControllerTheme) -> Swift.Bool
  @objc deinit
}
@objc @_Concurrency.MainActor(unsafe) open class AlertController : Display.ViewController, Display.StandalonePresentableController, Display.KeyShortcutResponder {
  @_Concurrency.MainActor(unsafe) public var theme: Display.AlertControllerTheme {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var willDismiss: (() -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) public var dismissed: ((Swift.Bool) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) public init(theme: Display.AlertControllerTheme, contentNode: Display.AlertContentNode, existingAlertController: Display.AlertController? = nil, allowInputInset: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) override open func loadDisplayNode()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) override open func containerLayoutUpdated(_ layout: Display.ContainerViewLayout, transition: Display.ContainedViewLayoutTransition)
  @_Concurrency.MainActor(unsafe) override open func dismiss(completion: (() -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) public func dismissAnimated()
  @_Concurrency.MainActor(unsafe) public var keyShortcuts: [Display.KeyShortcut] {
    get
  }
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class TextFieldNodeView : UIKit.UITextField {
  @_Concurrency.MainActor(unsafe) final public var didDeleteBackwardWhileEmpty: (() -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) @objc override final public func editingRect(forBounds bounds: CoreFoundation.CGRect) -> CoreFoundation.CGRect
  @_Concurrency.MainActor(unsafe) @objc override final public func textRect(forBounds bounds: CoreFoundation.CGRect) -> CoreFoundation.CGRect
  @_Concurrency.MainActor(unsafe) @objc override final public func placeholderRect(forBounds bounds: CoreFoundation.CGRect) -> CoreFoundation.CGRect
  @_Concurrency.MainActor(unsafe) @objc override final public func deleteBackward()
  @_Concurrency.MainActor(unsafe) @objc override final public var keyboardAppearance: UIKit.UIKeyboardAppearance {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc public class TextFieldNode : AsyncDisplayKit.ASDisplayNode {
  public var textField: Display.TextFieldNodeView {
    get
  }
  public var fixOffset: Swift.Bool {
    get
    set
  }
  @objc override dynamic public init()
  @objc deinit
}
public func childWindowHostView(parent: UIKit.UIView) -> Display.WindowHostView
public enum StatusBarStyle {
  case Black
  case White
  case Ignore
  case Hide
  public init(systemStyle: UIKit.UIStatusBarStyle)
  public var systemStyle: UIKit.UIStatusBarStyle {
    get
  }
  public static func == (a: Display.StatusBarStyle, b: Display.StatusBarStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class UITracingLayerView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) open func schedule(layout f: @escaping () -> Swift.Void)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var autoresizingMask: UIKit.UIView.AutoresizingMask {
    @objc get
    @objc set(value)
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public protocol ActionSheetItem {
  func node(theme: Display.ActionSheetControllerTheme) -> Display.ActionSheetItemNode
  func updateNode(_ node: Display.ActionSheetItemNode)
}
public struct ToolbarAction : Swift.Equatable {
  public enum Color : Swift.Equatable {
    case accent
    case custom(UIKit.UIColor)
    public static func == (a: Display.ToolbarAction.Color, b: Display.ToolbarAction.Color) -> Swift.Bool
  }
  public let title: Swift.String
  public let isEnabled: Swift.Bool
  public let color: Display.ToolbarAction.Color
  public init(title: Swift.String, isEnabled: Swift.Bool, color: Display.ToolbarAction.Color = .accent)
  public static func == (a: Display.ToolbarAction, b: Display.ToolbarAction) -> Swift.Bool
}
public struct Toolbar : Swift.Equatable {
  public let leftAction: Display.ToolbarAction?
  public let rightAction: Display.ToolbarAction?
  public let middleAction: Display.ToolbarAction?
  public init(leftAction: Display.ToolbarAction?, rightAction: Display.ToolbarAction?, middleAction: Display.ToolbarAction?)
  public static func == (a: Display.Toolbar, b: Display.Toolbar) -> Swift.Bool
}
public enum Keyboard {
  public static func applyAutocorrection(textView: UIKit.UITextView)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class HighlightableButton : Display.HighlightTrackingButton {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
@objc open class HighlightTrackingButtonNode : Display.ASButtonNode {
  public var highligthedChanged: (Swift.Bool) -> Swift.Void
  public var pointerInteraction: Display.PointerInteraction?
  public init(pointerStyle: Display.PointerStyle? = nil)
  @objc override dynamic open func didLoad()
  @objc override dynamic open func beginTracking(with touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @objc override dynamic open func endTracking(with touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @objc override dynamic open func cancelTracking(with event: UIKit.UIEvent?)
  @objc override dynamic open func touchesCancelled(_ touches: Swift.Set<UIKit.UITouch>?, with event: UIKit.UIEvent?)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers open class HighlightableButtonNode : Display.HighlightTrackingButtonNode {
  override public init(pointerStyle: Display.PointerStyle? = nil)
  @objc deinit
}
@objc open class ContextReferenceContentNode : AsyncDisplayKit.ASDisplayNode {
  @objc override dynamic public init()
  @objc deinit
}
@objc final public class ContextExtractedContentContainingNode : AsyncDisplayKit.ASDisplayNode {
  final public let contentNode: Display.ContextExtractedContentNode
  final public var contentRect: CoreFoundation.CGRect
  final public var isExtractedToContextPreview: Swift.Bool
  final public var willUpdateIsExtractedToContextPreview: ((Swift.Bool, Display.ContainedViewLayoutTransition) -> Swift.Void)?
  final public var isExtractedToContextPreviewUpdated: ((Swift.Bool) -> Swift.Void)?
  final public var updateAbsoluteRect: ((CoreFoundation.CGRect, CoreFoundation.CGSize) -> Swift.Void)?
  final public var applyAbsoluteOffset: ((CoreFoundation.CGPoint, Display.ContainedViewLayoutTransitionCurve, Swift.Double) -> Swift.Void)?
  final public var applyAbsoluteOffsetSpring: ((CoreFoundation.CGFloat, Swift.Double, CoreFoundation.CGFloat) -> Swift.Void)?
  final public var layoutUpdated: ((CoreFoundation.CGSize, Display.ListViewItemUpdateAnimation) -> Swift.Void)?
  final public var updateDistractionFreeMode: ((Swift.Bool) -> Swift.Void)?
  final public var requestDismiss: (() -> Swift.Void)?
  @objc override dynamic public init()
  @objc override final public func hitTest(_ point: CoreFoundation.CGPoint, with event: UIKit.UIEvent?) -> UIKit.UIView?
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class ContextExtractedContentContainingView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) final public let contentView: Display.ContextExtractedContentView
  @_Concurrency.MainActor(unsafe) final public var contentRect: CoreFoundation.CGRect
  @_Concurrency.MainActor(unsafe) final public var isExtractedToContextPreview: Swift.Bool
  @_Concurrency.MainActor(unsafe) final public var willUpdateIsExtractedToContextPreview: ((Swift.Bool, Display.ContainedViewLayoutTransition) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var isExtractedToContextPreviewUpdated: ((Swift.Bool) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var updateAbsoluteRect: ((CoreFoundation.CGRect, CoreFoundation.CGSize) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var applyAbsoluteOffset: ((CoreFoundation.CGPoint, Display.ContainedViewLayoutTransitionCurve, Swift.Double) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var applyAbsoluteOffsetSpring: ((CoreFoundation.CGFloat, Swift.Double, CoreFoundation.CGFloat) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var layoutUpdated: ((CoreFoundation.CGSize, Display.ListViewItemUpdateAnimation) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var updateDistractionFreeMode: ((Swift.Bool) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var requestDismiss: (() -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override final public func hitTest(_ point: CoreFoundation.CGPoint, with event: UIKit.UIEvent?) -> UIKit.UIView?
  @objc deinit
}
@objc final public class ContextExtractedContentNode : AsyncDisplayKit.ASDisplayNode {
  final public var customHitTest: ((CoreFoundation.CGPoint) -> UIKit.UIView?)? {
    get
    set
  }
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class ContextExtractedContentView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) final public var customHitTest: ((CoreFoundation.CGPoint) -> UIKit.UIView?)?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override final public func hitTest(_ point: CoreFoundation.CGPoint, with event: UIKit.UIEvent?) -> UIKit.UIView?
  @objc deinit
}
@objc final public class ContextControllerContentNode : AsyncDisplayKit.ASDisplayNode {
  final public let sourceView: UIKit.UIView
  final public let controller: Display.ViewController
  public init(sourceView: UIKit.UIView, controller: Display.ViewController, tapped: @escaping () -> Swift.Void)
  @objc override final public func didLoad()
  final public func updateLayout(size: CoreFoundation.CGSize, transition: Display.ContainedViewLayoutTransition)
  @objc deinit
}
public enum ContextContentNode {
  case reference(view: UIKit.UIView)
  case extracted(node: Display.ContextExtractedContentContainingNode, keepInPlace: Swift.Bool)
  case controller(Display.ContextControllerContentNode)
}
public struct ListViewItemNodeLayout {
  public let contentSize: CoreFoundation.CGSize
  public let insets: UIKit.UIEdgeInsets
  public init()
  public init(contentSize: CoreFoundation.CGSize, insets: UIKit.UIEdgeInsets)
  public var size: CoreFoundation.CGSize {
    get
  }
}
public enum ListViewItemNodeVisibility : Swift.Equatable {
  case none
  case visible(CoreFoundation.CGFloat, CoreFoundation.CGRect)
  public static func == (a: Display.ListViewItemNodeVisibility, b: Display.ListViewItemNodeVisibility) -> Swift.Bool
}
public struct ListViewItemLayoutParams {
  public let width: CoreFoundation.CGFloat
  public let leftInset: CoreFoundation.CGFloat
  public let rightInset: CoreFoundation.CGFloat
  public let availableHeight: CoreFoundation.CGFloat
  public init(width: CoreFoundation.CGFloat, leftInset: CoreFoundation.CGFloat, rightInset: CoreFoundation.CGFloat, availableHeight: CoreFoundation.CGFloat)
}
@objc open class ListViewItemNode : AsyncDisplayKit.ASDisplayNode, Display.AccessibilityFocusableNode {
  public struct HeaderId : Swift.Hashable {
    public var space: Swift.AnyHashable
    public var id: Swift.AnyHashable
    public init(space: Swift.AnyHashable, id: Swift.AnyHashable)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Display.ListViewItemNode.HeaderId, b: Display.ListViewItemNode.HeaderId) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  final public var index: Swift.Int? {
    get
  }
  public var isHighlightedInOverlay: Swift.Bool
  public var accessoryItemNode: Display.ListViewAccessoryItemNode? {
    get
  }
  open func addAccessoryItemNode(_ accessoryItemNode: Display.ListViewAccessoryItemNode)
  open var extractedBackgroundNode: AsyncDisplayKit.ASDisplayNode? {
    get
  }
  public var attachedHeaderNodes: [Display.ListViewItemHeaderNode] {
    get
  }
  open func attachedHeaderNodesUpdated()
  open var preferredAnimationCurve: (CoreFoundation.CGFloat) -> CoreFoundation.CGFloat {
    get
  }
  final public var wantsTrailingItemSpaceUpdates: Swift.Bool
  final public var scrollPositioningInsets: UIKit.UIEdgeInsets
  final public var canBeUsedAsScrollToItemAnchor: Swift.Bool
  open var visibility: Display.ListViewItemNodeVisibility
  open var canBeSelected: Swift.Bool {
    get
  }
  open func visibleForSelection(at point: CoreFoundation.CGPoint) -> Swift.Bool
  open var canBeLongTapped: Swift.Bool {
    get
  }
  open var preventsTouchesToOtherItems: Swift.Bool {
    get
  }
  open func touchesToOtherItemsPrevented()
  open func tapped()
  open func longTapped()
  final public var insets: UIKit.UIEdgeInsets {
    get
    set
  }
  final public var contentSize: CoreFoundation.CGSize {
    get
    set(value)
  }
  public var transitionOffset: CoreFoundation.CGFloat {
    get
    set
  }
  public var layout: Display.ListViewItemNodeLayout {
    get
  }
  public var displayResourcesReady: SwiftSignalKit.Signal<Swift.Void, SwiftSignalKit.NoError> {
    get
  }
  public init(layerBacked: Swift.Bool, dynamicBounce: Swift.Bool = true, rotated: Swift.Bool = false, seeThrough: Swift.Bool = false)
  public var apparentHeightTransition: (CoreFoundation.CGFloat, CoreFoundation.CGFloat)? {
    get
  }
  @objc override dynamic open var frame: CoreFoundation.CGRect {
    @objc get
    @objc set(value)
  }
  @objc override dynamic open var bounds: CoreFoundation.CGRect {
    @objc get
    @objc set(value)
  }
  public var contentBounds: CoreFoundation.CGRect {
    get
  }
  @objc override dynamic open var position: CoreFoundation.CGPoint {
    @objc get
    @objc set(value)
  }
  final public var apparentFrame: CoreFoundation.CGRect {
    get
  }
  final public var apparentContentFrame: CoreFoundation.CGRect {
    get
  }
  final public var apparentBounds: CoreFoundation.CGRect {
    get
  }
  open func layoutAccessoryItemNode(_ accessoryItemNode: Display.ListViewAccessoryItemNode, leftInset: CoreFoundation.CGFloat, rightInset: CoreFoundation.CGFloat)
  open func layoutHeaderAccessoryItemNode(_ accessoryItemNode: Display.ListViewAccessoryItemNode)
  open func reuse()
  public func animate(timestamp: Swift.Double, invertOffsetDirection: inout Swift.Bool) -> Swift.Bool
  open func layoutForParams(_ params: Display.ListViewItemLayoutParams, item: Display.ListViewItem, previousItem: Display.ListViewItem?, nextItem: Display.ListViewItem?)
  public func animationForKey(_ key: Swift.String) -> Display.ListViewAnimation?
  final public func setAnimationForKey(_ key: Swift.String, animation: Display.ListViewAnimation?)
  final public func removeAllAnimations()
  public func addInsetsAnimationToValue(_ value: UIKit.UIEdgeInsets, duration: Swift.Double, beginAt: Swift.Double)
  public func addHeightAnimation(_ value: CoreFoundation.CGFloat, duration: Swift.Double, beginAt: Swift.Double, update: ((CoreFoundation.CGFloat, CoreFoundation.CGFloat) -> Swift.Void)? = nil)
  public func addApparentHeightAnimation(_ value: CoreFoundation.CGFloat, duration: Swift.Double, beginAt: Swift.Double, invertOffsetDirection: Swift.Bool = false, update: ((CoreFoundation.CGFloat, CoreFoundation.CGFloat) -> Swift.Void)? = nil)
  public func modifyApparentHeightAnimation(_ value: CoreFoundation.CGFloat, beginAt: Swift.Double)
  public func removeApparentHeightAnimation()
  public func addTransitionOffsetAnimation(_ value: CoreFoundation.CGFloat, duration: Swift.Double, beginAt: Swift.Double)
  open func animateInsertion(_ currentTimestamp: Swift.Double, duration: Swift.Double, short: Swift.Bool)
  open func animateAdded(_ currentTimestamp: Swift.Double, duration: Swift.Double)
  open func animateRemoved(_ currentTimestamp: Swift.Double, duration: Swift.Double)
  open func setHighlighted(_ highlighted: Swift.Bool, at point: CoreFoundation.CGPoint, animated: Swift.Bool)
  open func selected()
  open func secondaryAction(at point: CoreFoundation.CGPoint)
  open func isReorderable(at point: CoreFoundation.CGPoint) -> Swift.Bool
  open func animateFrameTransition(_ progress: CoreFoundation.CGFloat, _ currentValue: CoreFoundation.CGFloat)
  open func shouldAnimateHorizontalFrameTransition() -> Swift.Bool
  open func headers() -> [Display.ListViewItemHeader]?
  open func updateTrailingItemSpace(_ height: CoreFoundation.CGFloat, transition: Display.ContainedViewLayoutTransition)
  @objc override dynamic open func accessibilityElementDidBecomeFocused()
  public func updateFrame(_ frame: CoreFoundation.CGRect, within containerSize: CoreFoundation.CGSize, updateFrame: Swift.Bool = true)
  open func updateAbsoluteRect(_ rect: CoreFoundation.CGRect, within containerSize: CoreFoundation.CGSize)
  open func applyAbsoluteOffset(value: CoreFoundation.CGPoint, animationCurve: Display.ContainedViewLayoutTransitionCurve, duration: Swift.Double)
  open func snapshotForReordering() -> UIKit.UIView?
  @objc deinit
}
public let displayLinkDispatcher: Display.DisplayLinkDispatcher
public enum ImageCorner : Swift.Equatable {
  case Corner(CoreFoundation.CGFloat)
  case Tail(CoreFoundation.CGFloat, UIKit.UIImage)
  public var extendedInsets: CoreFoundation.CGSize {
    get
  }
  public var withoutTail: Display.ImageCorner {
    get
  }
  public var radius: CoreFoundation.CGFloat {
    get
  }
}
public func == (lhs: Display.ImageCorner, rhs: Display.ImageCorner) -> Swift.Bool
public func isRoundEqualCorners(_ corners: Display.ImageCorners) -> Swift.Bool
public struct ImageCorners : Swift.Equatable {
  public let topLeft: Display.ImageCorner
  public let topRight: Display.ImageCorner
  public let bottomLeft: Display.ImageCorner
  public let bottomRight: Display.ImageCorner
  public var isEmpty: Swift.Bool {
    get
  }
  public init(radius: CoreFoundation.CGFloat)
  public init(topLeft: Display.ImageCorner, topRight: Display.ImageCorner, bottomLeft: Display.ImageCorner, bottomRight: Display.ImageCorner)
  public init()
  public var extendedEdges: UIKit.UIEdgeInsets {
    get
  }
  public func withRemovedTails() -> Display.ImageCorners
}
public func == (lhs: Display.ImageCorners, rhs: Display.ImageCorners) -> Swift.Bool
@objc public class ImageNode : AsyncDisplayKit.ASDisplayNode {
  public var enableAnimatedTransition: Swift.Bool
  public var animateFirstTransition: Swift.Bool
  public var contentReady: SwiftSignalKit.Signal<Swift.Bool, SwiftSignalKit.NoError> {
    get
  }
  public var ready: SwiftSignalKit.Signal<Swift.Bool, SwiftSignalKit.NoError> {
    get
  }
  public var contentUpdated: ((UIKit.UIImage?) -> Swift.Void)?
  public init(enableHasImage: Swift.Bool = false, enableEmpty: Swift.Bool = false, enableAnimatedTransition: Swift.Bool = false)
  @objc deinit
  public func setSignal(_ signal: SwiftSignalKit.Signal<UIKit.UIImage?, SwiftSignalKit.NoError>)
  @objc override dynamic public func clearContents()
  public var image: UIKit.UIImage? {
    get
  }
}
public enum ContextMenuActionContent {
  case text(title: Swift.String, accessibilityLabel: Swift.String)
  case icon(UIKit.UIImage)
}
public struct ContextMenuAction {
  public let content: Display.ContextMenuActionContent
  public let action: () -> Swift.Void
  public init(content: Display.ContextMenuActionContent, action: @escaping () -> Swift.Void)
}
public enum TabBarItemSwipeDirection {
  case left
  case right
  public static func == (a: Display.TabBarItemSwipeDirection, b: Display.TabBarItemSwipeDirection) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol TabBarController : Display.ViewController {
  var currentController: Display.ViewController? { get }
  var controllers: [Display.ViewController] { get }
  var selectedIndex: Swift.Int { get set }
  func setControllers(_ controllers: [Display.ViewController], selectedIndex: Swift.Int?)
  func updateBackgroundAlpha(_ alpha: CoreFoundation.CGFloat, transition: Display.ContainedViewLayoutTransition)
  func frameForControllerTab(controller: Display.ViewController) -> CoreFoundation.CGRect?
  func isPointInsideContentArea(point: CoreFoundation.CGPoint) -> Swift.Bool
  func sourceNodesForController(at index: Swift.Int) -> [AsyncDisplayKit.ASDisplayNode]?
  func updateIsTabBarEnabled(_ value: Swift.Bool, transition: Display.ContainedViewLayoutTransition)
  func updateIsTabBarHidden(_ value: Swift.Bool, transition: Display.ContainedViewLayoutTransition)
  func updateLayout(transition: Display.ContainedViewLayoutTransition)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class PortalSourceView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) final public var needsGlobalPortal: Swift.Bool {
    get
    set
  }
  @objc deinit
  @_Concurrency.MainActor(unsafe) public func addPortal(view: Display.PortalView)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func didMoveToWindow()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
}
@objc open class ViewControllerTracingNode : AsyncDisplayKit.ASDisplayNode {
  @objc override dynamic public init()
  @objc override dynamic open func didLoad()
  @objc deinit
}
public struct InteractiveTransitionGestureRecognizerDirections : Swift.OptionSet {
  public var rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  public static let leftEdge: Display.InteractiveTransitionGestureRecognizerDirections
  public static let rightEdge: Display.InteractiveTransitionGestureRecognizerDirections
  public static let leftCenter: Display.InteractiveTransitionGestureRecognizerDirections
  public static let rightCenter: Display.InteractiveTransitionGestureRecognizerDirections
  public static let left: Display.InteractiveTransitionGestureRecognizerDirections
  public static let right: Display.InteractiveTransitionGestureRecognizerDirections
  public typealias ArrayLiteralElement = Display.InteractiveTransitionGestureRecognizerDirections
  public typealias Element = Display.InteractiveTransitionGestureRecognizerDirections
  public typealias RawValue = Swift.Int
}
public enum InteractiveTransitionGestureRecognizerEdgeWidth {
  case constant(CoreFoundation.CGFloat)
  case widthMultiplier(factor: CoreFoundation.CGFloat, min: CoreFoundation.CGFloat, max: CoreFoundation.CGFloat)
}
@objc @_Concurrency.MainActor(unsafe) public class InteractiveTransitionGestureRecognizer : UIKit.UIPanGestureRecognizer {
  @_Concurrency.MainActor(unsafe) public init(target: Any?, action: ObjectiveC.Selector?, allowedDirections: @escaping (CoreFoundation.CGPoint) -> Display.InteractiveTransitionGestureRecognizerDirections, edgeWidth: Display.InteractiveTransitionGestureRecognizerEdgeWidth = .constant(16.0))
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func reset()
  @_Concurrency.MainActor(unsafe) public func cancel()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func touchesMoved(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @objc deinit
}
public protocol NavigationButtonCustomDisplayNode {
  var isHighlightable: Swift.Bool { get }
}
@objc @_inheritsConvenienceInitializers final public class NavigationButtonNode : Display.ContextControllerSourceNode {
  final public var singleCustomNode: AsyncDisplayKit.ASDisplayNode? {
    get
  }
  final public var pressed: (Swift.Int) -> ()
  final public var highlightChanged: (Swift.Int, Swift.Bool) -> ()
  final public var color: UIKit.UIColor {
    get
    set
  }
  final public var rippleColor: UIKit.UIColor {
    get
    set
  }
  final public var disabledColor: UIKit.UIColor {
    get
    set
  }
  @objc override final public var accessibilityElements: [Any]? {
    @objc get
    @objc set(value)
  }
  @objc override dynamic public init()
  final public func updateManualAlpha(alpha: CoreFoundation.CGFloat, transition: Display.ContainedViewLayoutTransition)
  final public func updateLayout(constrainedSize: CoreFoundation.CGSize, isLandscape: Swift.Bool) -> CoreFoundation.CGSize
  @objc deinit
}
public enum ListViewItemUpdateAnimation {
  case None
  case System(duration: Swift.Double, transition: Display.ControlledTransition)
  case Crossfade
  public var isAnimated: Swift.Bool {
    get
  }
  public var animator: Display.ControlledTransitionAnimator {
    get
  }
  public var transition: Display.ContainedViewLayoutTransition {
    get
  }
}
public struct ListViewItemConfigureNodeFlags : Swift.OptionSet {
  public var rawValue: Swift.Int32
  public init()
  public init(rawValue: Swift.Int32)
  public static let preferSynchronousResourceLoading: Display.ListViewItemConfigureNodeFlags
  public typealias ArrayLiteralElement = Display.ListViewItemConfigureNodeFlags
  public typealias Element = Display.ListViewItemConfigureNodeFlags
  public typealias RawValue = Swift.Int32
}
final public class ListViewItemApply {
  final public let isOnScreen: Swift.Bool
  final public let timestamp: Swift.Double?
  final public var invertOffsetDirection: Swift.Bool {
    get
  }
  public init(isOnScreen: Swift.Bool, timestamp: Swift.Double? = nil)
  final public func setInvertOffsetDirection()
  @objc deinit
}
public protocol ListViewItem {
  func nodeConfiguredForParams(async: @escaping (@escaping () -> Swift.Void) -> Swift.Void, params: Display.ListViewItemLayoutParams, synchronousLoads: Swift.Bool, previousItem: Display.ListViewItem?, nextItem: Display.ListViewItem?, completion: @escaping (Display.ListViewItemNode, @escaping () -> (SwiftSignalKit.Signal<Swift.Void, SwiftSignalKit.NoError>?, (Display.ListViewItemApply) -> Swift.Void)) -> Swift.Void)
  func updateNode(async: @escaping (@escaping () -> Swift.Void) -> Swift.Void, node: @escaping () -> Display.ListViewItemNode, params: Display.ListViewItemLayoutParams, previousItem: Display.ListViewItem?, nextItem: Display.ListViewItem?, animation: Display.ListViewItemUpdateAnimation, completion: @escaping (Display.ListViewItemNodeLayout, @escaping (Display.ListViewItemApply) -> Swift.Void) -> Swift.Void)
  var accessoryItem: Display.ListViewAccessoryItem? { get }
  var headerAccessoryItem: Display.ListViewAccessoryItem? { get }
  var selectable: Swift.Bool { get }
  var approximateHeight: CoreFoundation.CGFloat { get }
  func selected(listView: Display.ListView)
}
extension Display.ListViewItem {
  public var accessoryItem: Display.ListViewAccessoryItem? {
    get
  }
  public var headerAccessoryItem: Display.ListViewAccessoryItem? {
    get
  }
  public var selectable: Swift.Bool {
    get
  }
  public var approximateHeight: CoreFoundation.CGFloat {
    get
  }
  public func selected(listView: Display.ListView)
  public func performSecondaryAction(listView: Display.ListView)
}
public struct PresentationSurfaceLevel : Swift.RawRepresentable {
  public var rawValue: Swift.Int32
  public init(rawValue: Swift.Int32)
  public static let root: Display.PresentationSurfaceLevel
  public typealias RawValue = Swift.Int32
}
public enum PresentationContextType {
  case current
  case window(Display.PresentationSurfaceLevel)
}
@_hasMissingDesignatedInitializers final public class PresentationContext {
  final public var topLevelSubview: () -> UIKit.UIView?
  final public func present(_ controller: Display.ContainableController, on level: Display.PresentationSurfaceLevel, blockInteraction: Swift.Bool = false, completion: @escaping () -> Swift.Void)
  @objc deinit
  final public func containerLayoutUpdated(_ layout: Display.ContainerViewLayout, transition: Display.ContainedViewLayoutTransition)
}
public enum TransformImageResizeMode {
  case fill(UIKit.UIColor)
  case aspectFill
  case blurBackground
}
public protocol TransformImageCustomArguments {
  func serialized() -> Foundation.NSArray
}
public struct TransformImageArguments : Swift.Equatable {
  public var corners: Display.ImageCorners
  public var imageSize: CoreFoundation.CGSize
  public var boundingSize: CoreFoundation.CGSize
  public var intrinsicInsets: UIKit.UIEdgeInsets
  public var resizeMode: Display.TransformImageResizeMode
  public var emptyColor: UIKit.UIColor?
  public var custom: Display.TransformImageCustomArguments?
  public var scale: CoreFoundation.CGFloat?
  public init(corners: Display.ImageCorners, imageSize: CoreFoundation.CGSize, boundingSize: CoreFoundation.CGSize, intrinsicInsets: UIKit.UIEdgeInsets, resizeMode: Display.TransformImageResizeMode = .fill(.black), emptyColor: UIKit.UIColor? = nil, custom: Display.TransformImageCustomArguments? = nil, scale: CoreFoundation.CGFloat? = nil)
  public var drawingSize: CoreFoundation.CGSize {
    get
  }
  public var drawingRect: CoreFoundation.CGRect {
    get
  }
  public var imageRect: CoreFoundation.CGRect {
    get
  }
  public var insets: UIKit.UIEdgeInsets {
    get
  }
  public static func == (lhs: Display.TransformImageArguments, rhs: Display.TransformImageArguments) -> Swift.Bool
}
@objc open class SwitchNode : AsyncDisplayKit.ASDisplayNode {
  public var valueUpdated: ((Swift.Bool) -> Swift.Void)?
  public var frameColor: UIKit.UIColor {
    get
    set
  }
  public var handleColor: UIKit.UIColor {
    get
    set
  }
  public var contentColor: UIKit.UIColor {
    get
    set
  }
  public var isOn: Swift.Bool {
    get
    set(value)
  }
  @objc override dynamic public init()
  @objc override dynamic open func didLoad()
  public func setOn(_ value: Swift.Bool, animated: Swift.Bool)
  @objc override dynamic open func calculateSizeThatFits(_ constrainedSize: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  @objc deinit
}
public enum ListViewCenterScrollPositionOverflow {
  case top
  case bottom
  public static func == (a: Display.ListViewCenterScrollPositionOverflow, b: Display.ListViewCenterScrollPositionOverflow) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ListViewScrollPosition : Swift.Equatable {
  case top(CoreFoundation.CGFloat)
  case bottom(CoreFoundation.CGFloat)
  case center(Display.ListViewCenterScrollPositionOverflow)
  case visible
  public static func == (a: Display.ListViewScrollPosition, b: Display.ListViewScrollPosition) -> Swift.Bool
}
public enum ListViewScrollToItemDirectionHint {
  case Up
  case Down
  public static func == (a: Display.ListViewScrollToItemDirectionHint, b: Display.ListViewScrollToItemDirectionHint) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ListViewAnimationCurve {
  case Spring(duration: Swift.Double)
  case Default(duration: Swift.Double?)
  case Custom(duration: Swift.Double, Swift.Float, Swift.Float, Swift.Float, Swift.Float)
}
public struct ListViewScrollToItem {
  public let index: Swift.Int
  public let position: Display.ListViewScrollPosition
  public let animated: Swift.Bool
  public let curve: Display.ListViewAnimationCurve
  public let directionHint: Display.ListViewScrollToItemDirectionHint
  public let displayLink: Swift.Bool
  public init(index: Swift.Int, position: Display.ListViewScrollPosition, animated: Swift.Bool, curve: Display.ListViewAnimationCurve, directionHint: Display.ListViewScrollToItemDirectionHint, displayLink: Swift.Bool = false)
}
public enum ListViewItemOperationDirectionHint {
  case Up
  case Down
  public static func == (a: Display.ListViewItemOperationDirectionHint, b: Display.ListViewItemOperationDirectionHint) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ListViewDeleteItem {
  public let index: Swift.Int
  public let directionHint: Display.ListViewItemOperationDirectionHint?
  public init(index: Swift.Int, directionHint: Display.ListViewItemOperationDirectionHint?)
}
public struct ListViewInsertItem {
  public let index: Swift.Int
  public let previousIndex: Swift.Int?
  public let item: Display.ListViewItem
  public let directionHint: Display.ListViewItemOperationDirectionHint?
  public let forceAnimateInsertion: Swift.Bool
  public init(index: Swift.Int, previousIndex: Swift.Int?, item: Display.ListViewItem, directionHint: Display.ListViewItemOperationDirectionHint?, forceAnimateInsertion: Swift.Bool = false)
}
public struct ListViewUpdateItem {
  public let index: Swift.Int
  public let previousIndex: Swift.Int
  public let item: Display.ListViewItem
  public let directionHint: Display.ListViewItemOperationDirectionHint?
  public init(index: Swift.Int, previousIndex: Swift.Int, item: Display.ListViewItem, directionHint: Display.ListViewItemOperationDirectionHint?)
}
public struct ListViewDeleteAndInsertOptions : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  public static let AnimateInsertion: Display.ListViewDeleteAndInsertOptions
  public static let AnimateAlpha: Display.ListViewDeleteAndInsertOptions
  public static let LowLatency: Display.ListViewDeleteAndInsertOptions
  public static let Synchronous: Display.ListViewDeleteAndInsertOptions
  public static let RequestItemInsertionAnimations: Display.ListViewDeleteAndInsertOptions
  public static let AnimateTopItemPosition: Display.ListViewDeleteAndInsertOptions
  public static let PreferSynchronousDrawing: Display.ListViewDeleteAndInsertOptions
  public static let PreferSynchronousResourceLoading: Display.ListViewDeleteAndInsertOptions
  public static let AnimateCrossfade: Display.ListViewDeleteAndInsertOptions
  public static let ForceUpdate: Display.ListViewDeleteAndInsertOptions
  public typealias ArrayLiteralElement = Display.ListViewDeleteAndInsertOptions
  public typealias Element = Display.ListViewDeleteAndInsertOptions
  public typealias RawValue = Swift.Int
}
public struct ListViewUpdateSizeAndInsets {
  public let size: CoreFoundation.CGSize
  public let insets: UIKit.UIEdgeInsets
  public let headerInsets: UIKit.UIEdgeInsets?
  public let scrollIndicatorInsets: UIKit.UIEdgeInsets?
  public let duration: Swift.Double
  public let curve: Display.ListViewAnimationCurve
  public let ensureTopInsetForOverlayHighlightedItems: CoreFoundation.CGFloat?
  public init(size: CoreFoundation.CGSize, insets: UIKit.UIEdgeInsets, headerInsets: UIKit.UIEdgeInsets? = nil, scrollIndicatorInsets: UIKit.UIEdgeInsets? = nil, duration: Swift.Double, curve: Display.ListViewAnimationCurve, ensureTopInsetForOverlayHighlightedItems: CoreFoundation.CGFloat? = nil)
}
public struct ListViewItemRange : Swift.Equatable {
  public let firstIndex: Swift.Int
  public let lastIndex: Swift.Int
  public static func == (a: Display.ListViewItemRange, b: Display.ListViewItemRange) -> Swift.Bool
}
public struct ListViewVisibleItemRange : Swift.Equatable {
  public let firstIndex: Swift.Int
  public let firstIndexFullyVisible: Swift.Bool
  public let lastIndex: Swift.Int
  public static func == (a: Display.ListViewVisibleItemRange, b: Display.ListViewVisibleItemRange) -> Swift.Bool
}
public struct ListViewDisplayedItemRange : Swift.Equatable {
  public let loadedRange: Display.ListViewItemRange?
  public let visibleRange: Display.ListViewVisibleItemRange?
  public static func == (a: Display.ListViewDisplayedItemRange, b: Display.ListViewDisplayedItemRange) -> Swift.Bool
}
extension UIKit.UIResponder {
  @_Concurrency.MainActor(unsafe) public static func currentFirst() -> UIKit.UIResponder?
}
public func viewTreeContainsFirstResponder(view: UIKit.UIView) -> Swift.Bool
@_hasMissingDesignatedInitializers final public class KeyboardViewManager {
  final public func dismissEditingWithoutAnimation(view: UIKit.UIView)
  final public func update(leftEdge: CoreFoundation.CGFloat, transition: Display.ContainedViewLayoutTransition)
  @objc deinit
}
public func bezierPoint(_ x1: CoreFoundation.CGFloat, _ y1: CoreFoundation.CGFloat, _ x2: CoreFoundation.CGFloat, _ y2: CoreFoundation.CGFloat, _ x: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
@objc final public class ContextMenuContainerNode : AsyncDisplayKit.ASDisplayNode {
  final public var relativeArrowPosition: (CoreFoundation.CGFloat, Swift.Bool)?
  @objc override dynamic public init()
  @objc override final public func didLoad()
  @objc override final public func layout()
  final public func updateLayout(transition: Display.ContainedViewLayoutTransition)
  @objc deinit
}
@objc open class ASTransformLayerNode : AsyncDisplayKit.ASDisplayNode {
  @objc override dynamic public init()
  @objc deinit
}
@objc open class ASTransformViewNode : AsyncDisplayKit.ASDisplayNode {
  @objc override dynamic public init()
  @objc deinit
}
@objc open class ASTransformNode : AsyncDisplayKit.ASDisplayNode {
  public init(layerBacked: Swift.Bool = true)
  @objc deinit
}
@objc final public class ContextContentContainerNode : AsyncDisplayKit.ASDisplayNode {
  final public var contentNode: Display.ContextContentNode?
  @objc override dynamic public init()
  final public func updateLayout(size: CoreFoundation.CGSize, scaledSize: CoreFoundation.CGSize, transition: Display.ContainedViewLayoutTransition)
  @objc deinit
}
public protocol GridSection {
  var height: CoreFoundation.CGFloat { get }
  var hashValue: Swift.Int { get }
  func isEqual(to: Display.GridSection) -> Swift.Bool
  func node() -> AsyncDisplayKit.ASDisplayNode
}
public protocol GridItem {
  var section: Display.GridSection? { get }
  func node(layout: Display.GridNodeLayout, synchronousLoad: Swift.Bool) -> Display.GridItemNode
  func update(node: Display.GridItemNode)
  var aspectRatio: CoreFoundation.CGFloat { get }
  var fillsRowWithHeight: (CoreFoundation.CGFloat, Swift.Bool)? { get }
  var fillsRowWithDynamicHeight: ((CoreFoundation.CGFloat) -> CoreFoundation.CGFloat)? { get }
  var customItemSize: CoreFoundation.CGSize? { get }
}
extension Display.GridItem {
  public var aspectRatio: CoreFoundation.CGFloat {
    get
  }
  public var fillsRowWithHeight: (CoreFoundation.CGFloat, Swift.Bool)? {
    get
  }
  public var fillsRowWithDynamicHeight: ((CoreFoundation.CGFloat) -> CoreFoundation.CGFloat)? {
    get
  }
  public var customItemSize: CoreFoundation.CGSize? {
    get
  }
}
final public class ContextMenuControllerPresentationArguments {
  public init(sourceNodeAndRect: @escaping () -> (AsyncDisplayKit.ASDisplayNode, CoreFoundation.CGRect, AsyncDisplayKit.ASDisplayNode, CoreFoundation.CGRect)?, bounce: Swift.Bool = true)
  @objc deinit
}
@objc @_Concurrency.MainActor(unsafe) final public class ContextMenuController : Display.ViewController, Display.KeyShortcutResponder, Display.StandalonePresentableController {
  @_Concurrency.MainActor(unsafe) final public var keyShortcuts: [Display.KeyShortcut] {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var dismissed: (() -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) public init(actions: [Display.ContextMenuAction], catchTapsOutside: Swift.Bool = false, hasHapticFeedback: Swift.Bool = false)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) override final public func loadDisplayNode()
  @_Concurrency.MainActor(unsafe) @objc override final public func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) override final public func dismiss(completion: (() -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) override final public func containerLayoutUpdated(_ layout: Display.ContainerViewLayout, transition: Display.ContainedViewLayoutTransition)
  @_Concurrency.MainActor(unsafe) @objc override final public func viewWillAppear(_ animated: Swift.Bool)
  @objc deinit
}
public class ActionSheetTextItem : Display.ActionSheetItem {
  final public let title: Swift.String
  final public let parseMarkdown: Swift.Bool
  public init(title: Swift.String, parseMarkdown: Swift.Bool = true)
  public func node(theme: Display.ActionSheetControllerTheme) -> Display.ActionSheetItemNode
  public func updateNode(_ node: Display.ActionSheetItemNode)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class ActionSheetTextNode : Display.ActionSheetItemNode {
  override public init(theme: Display.ActionSheetControllerTheme)
  override public func updateLayout(constrainedSize: CoreFoundation.CGSize, transition: Display.ContainedViewLayoutTransition) -> CoreFoundation.CGSize
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class ListViewTapGestureRecognizer : UIKit.UITapGestureRecognizer {
  @_Concurrency.MainActor(unsafe) final public func cancel()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(target: Any?, action: ObjectiveC.Selector?)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class GridNodeScrollerView : UIKit.UIScrollView {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public class var layerClass: Swift.AnyClass {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func touchesShouldCancel(in view: UIKit.UIView) -> Swift.Bool
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) open class GridNodeScroller : AsyncDisplayKit.ASDisplayNode, UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor(unsafe) public var scrollView: UIKit.UIScrollView {
    get
  }
  @_Concurrency.MainActor(unsafe) required public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
@objc public class NavigationTitleNode : AsyncDisplayKit.ASDisplayNode {
  public var text: Foundation.NSString {
    get
    set(value)
  }
  public var color: UIKit.UIColor {
    get
    set
  }
  public init(text: Foundation.NSString)
  required public init(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic public func calculateSizeThatFits(_ constrainedSize: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  @objc override dynamic public func layout()
  @objc deinit
}
public enum GridNodeVisibleContentOffset {
  case known(CoreFoundation.CGFloat)
  case unknown
  case none
}
public struct GridNodeInsertItem {
  public let index: Swift.Int
  public let item: Display.GridItem
  public let previousIndex: Swift.Int?
  public init(index: Swift.Int, item: Display.GridItem, previousIndex: Swift.Int?)
}
public struct GridNodeUpdateItem {
  public let index: Swift.Int
  public let previousIndex: Swift.Int
  public let item: Display.GridItem
  public init(index: Swift.Int, previousIndex: Swift.Int, item: Display.GridItem)
}
public enum GridNodeScrollToItemPosition {
  case top(CoreFoundation.CGFloat)
  case bottom(CoreFoundation.CGFloat)
  case center(CoreFoundation.CGFloat)
  case visible
}
public struct GridNodeScrollToItem {
  public let index: Swift.Int
  public let position: Display.GridNodeScrollToItemPosition
  public let transition: Display.ContainedViewLayoutTransition
  public let directionHint: Display.GridNodePreviousItemsTransitionDirectionHint
  public let adjustForSection: Swift.Bool
  public let adjustForTopInset: Swift.Bool
  public init(index: Swift.Int, position: Display.GridNodeScrollToItemPosition, transition: Display.ContainedViewLayoutTransition, directionHint: Display.GridNodePreviousItemsTransitionDirectionHint, adjustForSection: Swift.Bool, adjustForTopInset: Swift.Bool = false)
}
public enum GridNodeLayoutType : Swift.Equatable {
  case fixed(itemSize: CoreFoundation.CGSize, fillWidth: Swift.Bool?, lineSpacing: CoreFoundation.CGFloat, itemSpacing: CoreFoundation.CGFloat?)
  case balanced(idealHeight: CoreFoundation.CGFloat)
  public static func == (a: Display.GridNodeLayoutType, b: Display.GridNodeLayoutType) -> Swift.Bool
}
public struct GridNodeLayout : Swift.Equatable {
  public let size: CoreFoundation.CGSize
  public let insets: UIKit.UIEdgeInsets
  public let scrollIndicatorInsets: UIKit.UIEdgeInsets?
  public let preloadSize: CoreFoundation.CGFloat
  public let type: Display.GridNodeLayoutType
  public let cutout: CoreFoundation.CGRect?
  public init(size: CoreFoundation.CGSize, insets: UIKit.UIEdgeInsets, scrollIndicatorInsets: UIKit.UIEdgeInsets? = nil, preloadSize: CoreFoundation.CGFloat, type: Display.GridNodeLayoutType, cutout: CoreFoundation.CGRect? = nil)
  public static func == (a: Display.GridNodeLayout, b: Display.GridNodeLayout) -> Swift.Bool
}
public struct GridNodeUpdateLayout {
  public let layout: Display.GridNodeLayout
  public let transition: Display.ContainedViewLayoutTransition
  public init(layout: Display.GridNodeLayout, transition: Display.ContainedViewLayoutTransition)
}
public enum GridNodeStationaryItems {
  case none
  case all
  case indices(Swift.Set<Swift.Int>)
}
public struct GridNodeTransaction {
  public let deleteItems: [Swift.Int]
  public let insertItems: [Display.GridNodeInsertItem]
  public let updateItems: [Display.GridNodeUpdateItem]
  public let scrollToItem: Display.GridNodeScrollToItem?
  public let updateLayout: Display.GridNodeUpdateLayout?
  public let itemTransition: Display.ContainedViewLayoutTransition
  public let stationaryItems: Display.GridNodeStationaryItems
  public let updateFirstIndexInSectionOffset: Swift.Int?
  public let updateOpaqueState: Any?
  public let synchronousLoads: Swift.Bool
  public init(deleteItems: [Swift.Int], insertItems: [Display.GridNodeInsertItem], updateItems: [Display.GridNodeUpdateItem], scrollToItem: Display.GridNodeScrollToItem?, updateLayout: Display.GridNodeUpdateLayout?, itemTransition: Display.ContainedViewLayoutTransition, stationaryItems: Display.GridNodeStationaryItems, updateFirstIndexInSectionOffset: Swift.Int?, updateOpaqueState: Any? = nil, synchronousLoads: Swift.Bool = false)
}
public enum GridNodePreviousItemsTransitionDirectionHint {
  case up
  case down
  public static func == (a: Display.GridNodePreviousItemsTransitionDirectionHint, b: Display.GridNodePreviousItemsTransitionDirectionHint) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct GridNodeCurrentPresentationLayout {
  public let layout: Display.GridNodeLayout
  public let contentOffset: CoreFoundation.CGPoint
  public let contentSize: CoreFoundation.CGSize
}
public struct GridNodeDisplayedItemRange : Swift.Equatable {
  public let loadedRange: Swift.Range<Swift.Int>?
  public let visibleRange: Swift.Range<Swift.Int>?
  public static func == (a: Display.GridNodeDisplayedItemRange, b: Display.GridNodeDisplayedItemRange) -> Swift.Bool
}
public struct GridNodeVisibleItems {
  public let top: (Swift.Int, Display.GridItem)?
  public let bottom: (Swift.Int, Display.GridItem)?
  public let topVisible: (Swift.Int, Display.GridItem)?
  public let bottomVisible: (Swift.Int, Display.GridItem)?
  public let topSectionVisible: Display.GridSection?
  public let count: Swift.Int
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class GridNode : Display.GridNodeScroller, UIKit.UIScrollViewDelegate {
  @_Concurrency.MainActor(unsafe) public var gridLayout: Display.GridNodeLayout {
    get
  }
  @_Concurrency.MainActor(unsafe) public var items: [Display.GridItem] {
    get
  }
  @_Concurrency.MainActor(unsafe) public var setupNode: ((Display.GridItemNode) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) public var visibleItemsUpdated: ((Display.GridNodeVisibleItems) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) public var presentationLayoutUpdated: ((Display.GridNodeCurrentPresentationLayout, Display.ContainedViewLayoutTransition) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) public var scrollingInitiated: (() -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) public var scrollingCompleted: (() -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) public var interactiveScrollingEnded: (() -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) public var interactiveScrollingWillBeEnded: ((CoreFoundation.CGPoint, CoreFoundation.CGPoint, CoreFoundation.CGPoint) -> CoreFoundation.CGPoint)?
  @_Concurrency.MainActor(unsafe) public var visibleContentOffsetChanged: (Display.GridNodeVisibleContentOffset) -> Swift.Void
  @_Concurrency.MainActor(unsafe) final public var floatingSections: Swift.Bool
  @_Concurrency.MainActor(unsafe) final public var initialOffset: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) public var showVerticalScrollIndicator: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var indicatorStyle: UIKit.UIScrollView.IndicatorStyle {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var opaqueState: Any? {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc dynamic public init()
  @_Concurrency.MainActor(unsafe) required public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
  @_Concurrency.MainActor(unsafe) public func transaction(_ transaction: Display.GridNodeTransaction, completion: (Display.GridNodeDisplayedItemRange) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) public func autoscroll(toOffset: CoreFoundation.CGPoint, duration: Swift.Double)
  @_Concurrency.MainActor(unsafe) @objc public func scrollViewWillBeginDragging(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc public func scrollViewWillEndDragging(_ scrollView: UIKit.UIScrollView, withVelocity velocity: CoreFoundation.CGPoint, targetContentOffset: Swift.UnsafeMutablePointer<CoreFoundation.CGPoint>)
  @_Concurrency.MainActor(unsafe) @objc public func scrollViewDidEndDragging(_ scrollView: UIKit.UIScrollView, willDecelerate decelerate: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc public func scrollViewDidEndDecelerating(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) @objc public func scrollViewDidScroll(_ scrollView: UIKit.UIScrollView)
  @_Concurrency.MainActor(unsafe) public func lowestSectionNode() -> AsyncDisplayKit.ASDisplayNode?
  @_Concurrency.MainActor(unsafe) public var forceHidden: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public func visibleContentOffset() -> Display.GridNodeVisibleContentOffset
  @_Concurrency.MainActor(unsafe) public func forEachItemNode(_ f: (AsyncDisplayKit.ASDisplayNode) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) public func forEachRow(_ f: ([AsyncDisplayKit.ASDisplayNode]) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) public func itemNodeAtPoint(_ point: CoreFoundation.CGPoint) -> AsyncDisplayKit.ASDisplayNode?
}
public enum ImpactHapticFeedbackStyle : Swift.Hashable {
  case light
  case medium
  case heavy
  case soft
  case rigid
  case veryLight
  case click05
  case click06
  public static func == (a: Display.ImpactHapticFeedbackStyle, b: Display.ImpactHapticFeedbackStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class HapticFeedback {
  public init()
  @objc deinit
  final public func prepareTap()
  final public func tap()
  final public func prepareImpact(_ style: Display.ImpactHapticFeedbackStyle = .medium)
  final public func impact(_ style: Display.ImpactHapticFeedbackStyle = .medium)
  final public func success()
  final public func prepareError()
  final public func error()
  final public func warning()
}
@available(iOS 13.0, *)
final public class ContinuousHaptic {
  public init(duration: Swift.Double) throws
  @objc deinit
}
public class PortalView {
  final public let view: UIKit.UIView & UIKitRuntimeUtils.UIKitPortalViewProtocol
  public init?(matchPosition: Swift.Bool = true)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers final public class NullActionClass : ObjectiveC.NSObject, QuartzCore.CAAction {
  @objc final public func run(forKey event: Swift.String, object anObject: Any, arguments dict: [Swift.AnyHashable : Any]?)
  @objc override dynamic public init()
  @objc deinit
}
public let nullAction: Display.NullActionClass
@objc @_inheritsConvenienceInitializers open class SimpleLayer : QuartzCore.CALayer {
  public var didEnterHierarchy: (() -> Swift.Void)?
  public var didExitHierarchy: (() -> Swift.Void)?
  public var isInHierarchy: Swift.Bool {
    get
  }
  @objc override dynamic open func action(forKey event: Swift.String) -> QuartzCore.CAAction?
  @objc override dynamic public init()
  @objc override dynamic public init(layer: Any)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers open class SimpleShapeLayer : QuartzCore.CAShapeLayer {
  public var didEnterHierarchy: (() -> Swift.Void)?
  public var didExitHierarchy: (() -> Swift.Void)?
  @objc override dynamic open func action(forKey event: Swift.String) -> QuartzCore.CAAction?
  @objc override dynamic public init()
  @objc override dynamic public init(layer: Any)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers open class SimpleGradientLayer : QuartzCore.CAGradientLayer {
  public var didEnterHierarchy: (() -> Swift.Void)?
  public var didExitHierarchy: (() -> Swift.Void)?
  @objc override dynamic open func action(forKey event: Swift.String) -> QuartzCore.CAAction?
  @objc override dynamic public init()
  @objc override dynamic public init(layer: Any)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public struct WindowLayout : Swift.Equatable {
  public let size: CoreFoundation.CGSize
  public let metrics: Display.LayoutMetrics
  public let statusBarHeight: CoreFoundation.CGFloat?
  public let inputHeight: CoreFoundation.CGFloat?
  public let safeInsets: UIKit.UIEdgeInsets
  public static func == (a: Display.WindowLayout, b: Display.WindowLayout) -> Swift.Bool
}
public func doesViewTreeDisableInteractiveTransitionGestureRecognizer(_ view: UIKit.UIView, keyboardOnly: Swift.Bool = false) -> Swift.Bool
public func getFirstResponderAndAccessoryHeight(_ view: UIKit.UIView, _ accessoryHeight: CoreFoundation.CGFloat? = nil) -> (UIKit.UIView?, CoreFoundation.CGFloat?)
final public class WindowHostView {
  final public let containerView: UIKit.UIView
  final public let eventView: UIKit.UIView
  final public let isRotating: () -> Swift.Bool
  final public let systemUserInterfaceStyle: SwiftSignalKit.Signal<Display.WindowUserInterfaceStyle, SwiftSignalKit.NoError>
  final public let updateSupportedInterfaceOrientations: (UIKit.UIInterfaceOrientationMask) -> Swift.Void
  final public let updateDeferScreenEdgeGestures: (UIKit.UIRectEdge) -> Swift.Void
  final public let updatePrefersOnScreenNavigationHidden: (Swift.Bool) -> Swift.Void
  final public var present: ((Display.ContainableController, Display.PresentationSurfaceLevel, Swift.Bool, @escaping () -> Swift.Void) -> Swift.Void)?
  final public var presentInGlobalOverlay: ((_ controller: Display.ContainableController) -> Swift.Void)?
  final public var addGlobalPortalHostViewImpl: ((Display.PortalSourceView) -> Swift.Void)?
  final public var presentNative: ((UIKit.UIViewController) -> Swift.Void)?
  final public var nativeController: (() -> UIKit.UIViewController?)?
  final public var updateSize: ((CoreFoundation.CGSize, Swift.Double) -> Swift.Void)?
  final public var layoutSubviews: (() -> Swift.Void)?
  final public var updateToInterfaceOrientation: ((UIKit.UIInterfaceOrientation) -> Swift.Void)?
  final public var isUpdatingOrientationLayout: Swift.Bool
  final public var hitTest: ((CoreFoundation.CGPoint, UIKit.UIEvent?) -> UIKit.UIView?)?
  final public var invalidateDeferScreenEdgeGesture: (() -> Swift.Void)?
  final public var invalidatePrefersOnScreenNavigationHidden: (() -> Swift.Void)?
  final public var invalidateSupportedOrientations: (() -> Swift.Void)?
  final public var cancelInteractiveKeyboardGestures: (() -> Swift.Void)?
  final public var forEachController: (((Display.ContainableController) -> Swift.Void) -> Swift.Void)?
  final public var getAccessibilityElements: (() -> [Any]?)?
  public init(containerView: UIKit.UIView, eventView: UIKit.UIView, isRotating: @escaping () -> Swift.Bool, systemUserInterfaceStyle: SwiftSignalKit.Signal<Display.WindowUserInterfaceStyle, SwiftSignalKit.NoError>, updateSupportedInterfaceOrientations: @escaping (UIKit.UIInterfaceOrientationMask) -> Swift.Void, updateDeferScreenEdgeGestures: @escaping (UIKit.UIRectEdge) -> Swift.Void, updatePrefersOnScreenNavigationHidden: @escaping (Swift.Bool) -> Swift.Void)
  @objc deinit
}
public protocol WindowHost {
  func forEachController(_ f: (Display.ContainableController) -> Swift.Void)
  func present(_ controller: Display.ContainableController, on level: Display.PresentationSurfaceLevel, blockInteraction: Swift.Bool, completion: @escaping () -> Swift.Void)
  func presentInGlobalOverlay(_ controller: Display.ContainableController)
  func addGlobalPortalHostView(sourceView: Display.PortalSourceView)
  func invalidateDeferScreenEdgeGestures()
  func invalidatePrefersOnScreenNavigationHidden()
  func invalidateSupportedOrientations()
  func cancelInteractiveKeyboardGestures()
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public var windowHost: Display.WindowHost? {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class WindowKeyboardGestureRecognizerDelegate : ObjectiveC.NSObject, UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor(unsafe) @objc final public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldRequireFailureOf otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init()
  @objc deinit
}
public class Window1 {
  final public let hostView: Display.WindowHostView
  final public let badgeView: UIKit.UIImageView
  public var deviceMetrics: Display.DeviceMetrics
  final public let statusBarHost: Display.StatusBarHost?
  final public let keyboardViewManager: Display.KeyboardViewManager?
  public var statusBarChangeObserver: Swift.AnyObject?
  public var keyboardRotationChangeObserver: Swift.AnyObject?
  public var keyboardFrameChangeObserver: Swift.AnyObject?
  public var keyboardTypeChangeObserver: Swift.AnyObject?
  public var voiceOverStatusObserver: Swift.AnyObject?
  public var windowLayout: Display.WindowLayout
  public var updatedContainerLayout: Display.ContainerViewLayout?
  public var upperKeyboardInputPositionBound: CoreFoundation.CGFloat?
  final public let presentationContext: Display.PresentationContext
  final public let topPresentationContext: Display.PresentationContext
  public var forceInCallStatusBarText: Swift.String? {
    get
  }
  public var inCallNavigate: (() -> Swift.Void)?
  public var debugAction: (() -> Swift.Void)? {
    get
    set
  }
  final public let systemUserInterfaceStyle: SwiftSignalKit.Signal<Display.WindowUserInterfaceStyle, SwiftSignalKit.NoError>
  public init(hostView: Display.WindowHostView, statusBarHost: Display.StatusBarHost?)
  required public init(coder aDecoder: Foundation.NSCoder)
  @objc deinit
  public func setForceBadgeHidden(_ hidden: Swift.Bool)
  public func setProximityDimHidden(_ hidden: Swift.Bool)
  public func setForceInCallStatusBar(_ forceInCallStatusBarText: Swift.String?, transition: Display.ContainedViewLayoutTransition = .animated(duration: 0.3, curve: .easeInOut))
  public func invalidateDeferScreenEdgeGestures()
  public func invalidatePrefersOnScreenNavigationHidden()
  public func invalidateSupportedOrientations()
  public func cancelInteractiveKeyboardGestures()
  public func hitTest(_ point: CoreFoundation.CGPoint, with event: UIKit.UIEvent?) -> UIKit.UIView?
  public var viewController: Display.ContainableController? {
    get
    set(value)
  }
  public var topLevelOverlayControllers: [Display.ContainableController] {
    get
    set(value)
  }
  public var coveringView: Display.WindowCoveringView? {
    get
    set
  }
  public func addPostUpdateToInterfaceOrientationBlock(f: @escaping () -> Swift.Void)
  public func present(_ controller: Display.ContainableController, on level: Display.PresentationSurfaceLevel, blockInteraction: Swift.Bool = false, completion: @escaping () -> Swift.Void = {})
  public func presentInGlobalOverlay(_ controller: Display.ContainableController)
  public func addGlobalPortalHostView(sourceView: Display.PortalSourceView)
  public func presentNative(_ controller: UIKit.UIViewController)
  public func simulateKeyboardDismiss(transition: Display.ContainedViewLayoutTransition)
  public func forEachViewController(_ f: (Display.ContainableController) -> Swift.Bool, excludeNavigationSubControllers: Swift.Bool = false)
  public func doNotAnimateLikelyKeyboardAutocorrectionSwitch()
}
public func findSubstringRanges(in string: Swift.String, query: Swift.String) -> ([Swift.Range<Swift.String.Index>], Swift.String)
public protocol WindowInputAccessoryHeightProvider : AnyObject {
  func getWindowInputAccessoryHeight() -> CoreFoundation.CGFloat
}
public protocol KeyShortcutResponder {
  var keyShortcuts: [Display.KeyShortcut] { get }
}
@objc @_Concurrency.MainActor(unsafe) public class KeyShortcutsController : UIKit.UIResponder {
  @_Concurrency.MainActor(unsafe) public static var isAvailable: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) public init(enumerator: @escaping (@escaping (Display.ContainableController) -> Swift.Bool) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var keyCommands: [UIKit.UIKeyCommand]? {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func canPerformAction(_ action: ObjectiveC.Selector, withSender sender: Any?) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func target(forAction action: ObjectiveC.Selector, withSender sender: Any?) -> Any?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var canBecomeFirstResponder: Swift.Bool {
    @objc get
  }
  @objc deinit
}
@objc @_inheritsConvenienceInitializers open class ListViewFloatingHeaderNode : AsyncDisplayKit.ASDisplayNode {
  open func updateLayout(width: CoreFoundation.CGFloat, leftInset: CoreFoundation.CGFloat, rightInset: CoreFoundation.CGFloat, transition: Display.ContainedViewLayoutTransition) -> CoreFoundation.CGFloat
  @objc override dynamic public init()
  @objc override dynamic public init(viewBlock: @escaping AsyncDisplayKit.ASDisplayNodeViewBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc override dynamic public init(layerBlock: @escaping AsyncDisplayKit.ASDisplayNodeLayerBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class WindowPanRecognizer : UIKit.UIGestureRecognizer {
  @_Concurrency.MainActor(unsafe) final public var began: ((CoreFoundation.CGPoint) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var moved: ((CoreFoundation.CGPoint) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var ended: ((CoreFoundation.CGPoint, CoreFoundation.CGPoint?) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) @objc override final public func reset()
  @_Concurrency.MainActor(unsafe) final public func cancel()
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesMoved(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesCancelled(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(target: Any?, action: ObjectiveC.Selector?)
  @objc deinit
}
@objc public class NavigationBackButtonNode : AsyncDisplayKit.ASControlNode {
  final public let label: Display.ImmediateTextNode
  public var text: Swift.String {
    get
    set(value)
  }
  public var color: UIKit.UIColor {
    get
    set
  }
  public var disabledColor: UIKit.UIColor {
    get
    set
  }
  @objc override dynamic public init()
  @objc override dynamic public func calculateSizeThatFits(_ constrainedSize: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  @objc override dynamic public func layout()
  @objc override dynamic public func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @objc override dynamic public func touchesMoved(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @objc override dynamic public func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @objc override dynamic public func touchesCancelled(_ touches: Swift.Set<UIKit.UITouch>?, with event: UIKit.UIEvent?)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class HighlightTrackingButton : UIKit.UIButton {
  @_Concurrency.MainActor(unsafe) public var internalHighligthedChanged: (Swift.Bool) -> Swift.Void
  @_Concurrency.MainActor(unsafe) public var highligthedChanged: (Swift.Bool) -> Swift.Void
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func beginTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func cancelTracking(with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func touchesCancelled(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public func generateRectsImage(color: UIKit.UIColor, rects: [CoreFoundation.CGRect], inset: CoreFoundation.CGFloat, outerRadius: CoreFoundation.CGFloat, innerRadius: CoreFoundation.CGFloat, stroke: Swift.Bool = false, useModernPathCalculation: Swift.Bool) -> (CoreFoundation.CGPoint, UIKit.UIImage?)
@objc final public class LinkHighlightingNode : AsyncDisplayKit.ASDisplayNode {
  final public var rects: [CoreFoundation.CGRect] {
    get
  }
  final public let imageNode: Display.ASImageNode
  final public var innerRadius: CoreFoundation.CGFloat
  final public var outerRadius: CoreFoundation.CGFloat
  final public var inset: CoreFoundation.CGFloat
  final public var useModernPathCalculation: Swift.Bool
  final public var color: UIKit.UIColor {
    get
    set(value)
  }
  public init(color: UIKit.UIColor)
  final public func updateRects(_ rects: [CoreFoundation.CGRect], color: UIKit.UIColor? = nil)
  public static func generateImage(color: UIKit.UIColor, inset: CoreFoundation.CGFloat, innerRadius: CoreFoundation.CGFloat, outerRadius: CoreFoundation.CGFloat, rects: [CoreFoundation.CGRect], useModernPathCalculation: Swift.Bool) -> (CoreFoundation.CGPoint, UIKit.UIImage)?
  final public func asyncLayout() -> (UIKit.UIColor, [CoreFoundation.CGRect], CoreFoundation.CGFloat, CoreFoundation.CGFloat, CoreFoundation.CGFloat) -> () -> Swift.Void
  @objc deinit
}
public let deviceColorSpace: CoreGraphics.CGColorSpace
public func generateImagePixel(_ size: CoreFoundation.CGSize, scale: CoreFoundation.CGFloat, pixelGenerator: (CoreFoundation.CGSize, Swift.UnsafeMutablePointer<Swift.UInt8>, Swift.Int) -> Swift.Void) -> UIKit.UIImage?
public func generateGrayscaleAlphaMaskImage(image: UIKit.UIImage) -> UIKit.UIImage?
public func generateImage(_ size: CoreFoundation.CGSize, contextGenerator: (CoreFoundation.CGSize, CoreGraphics.CGContext) -> Swift.Void, opaque: Swift.Bool = false, scale: CoreFoundation.CGFloat? = nil) -> UIKit.UIImage?
public func generateImage(_ size: CoreFoundation.CGSize, opaque: Swift.Bool = false, scale: CoreFoundation.CGFloat? = nil, rotatedContext: (CoreFoundation.CGSize, CoreGraphics.CGContext) -> Swift.Void) -> UIKit.UIImage?
public func generateFilledCircleImage(diameter: CoreFoundation.CGFloat, color: UIKit.UIColor?, strokeColor: UIKit.UIColor? = nil, strokeWidth: CoreFoundation.CGFloat? = nil, backgroundColor: UIKit.UIColor? = nil) -> UIKit.UIImage?
public func generateFilledRoundedRectImage(size: CoreFoundation.CGSize, cornerRadius: CoreFoundation.CGFloat, color: UIKit.UIColor?, strokeColor: UIKit.UIColor? = nil, strokeWidth: CoreFoundation.CGFloat? = nil, backgroundColor: UIKit.UIColor? = nil) -> UIKit.UIImage?
public func generateAdjustedStretchableFilledCircleImage(diameter: CoreFoundation.CGFloat, color: UIKit.UIColor) -> UIKit.UIImage?
public func generateCircleImage(diameter: CoreFoundation.CGFloat, lineWidth: CoreFoundation.CGFloat, color: UIKit.UIColor?, backgroundColor: UIKit.UIColor? = nil) -> UIKit.UIImage?
public func generateStretchableFilledCircleImage(radius: CoreFoundation.CGFloat, color: UIKit.UIColor?, backgroundColor: UIKit.UIColor? = nil) -> UIKit.UIImage?
public func generateStretchableFilledCircleImage(diameter: CoreFoundation.CGFloat, color: UIKit.UIColor?, strokeColor: UIKit.UIColor? = nil, strokeWidth: CoreFoundation.CGFloat? = nil, backgroundColor: UIKit.UIColor? = nil) -> UIKit.UIImage?
public func generateVerticallyStretchableFilledCircleImage(radius: CoreFoundation.CGFloat, color: UIKit.UIColor?, backgroundColor: UIKit.UIColor? = nil) -> UIKit.UIImage?
public func generateSmallHorizontalStretchableFilledCircleImage(diameter: CoreFoundation.CGFloat, color: UIKit.UIColor?, backgroundColor: UIKit.UIColor? = nil) -> UIKit.UIImage?
public func generateTintedImage(image: UIKit.UIImage?, color: UIKit.UIColor, backgroundColor: UIKit.UIColor? = nil) -> UIKit.UIImage?
public func generateGradientTintedImage(image: UIKit.UIImage?, colors: [UIKit.UIColor]) -> UIKit.UIImage?
public enum GradientImageDirection {
  case vertical
  case horizontal
  public static func == (a: Display.GradientImageDirection, b: Display.GradientImageDirection) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public func generateGradientImage(size: CoreFoundation.CGSize, colors: [UIKit.UIColor], locations: [CoreFoundation.CGFloat], direction: Display.GradientImageDirection = .vertical) -> UIKit.UIImage?
public func generateGradientFilledCircleImage(diameter: CoreFoundation.CGFloat, colors: Foundation.NSArray) -> UIKit.UIImage?
public func generateScaledImage(image: UIKit.UIImage?, size: CoreFoundation.CGSize, opaque: Swift.Bool = true, scale: CoreFoundation.CGFloat? = nil) -> UIKit.UIImage?
public func generateSingleColorImage(size: CoreFoundation.CGSize, color: UIKit.UIColor) -> UIKit.UIImage?
public enum DrawingContextBltMode {
  case Alpha
  public static func == (a: Display.DrawingContextBltMode, b: Display.DrawingContextBltMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public func getSharedDevideGraphicsContextSettings() -> Display.DeviceGraphicsContextSettings
public struct DeviceGraphicsContextSettings {
  public static let shared: Display.DeviceGraphicsContextSettings
  public let rowAlignment: Swift.Int
  public let bitsPerPixel: Swift.Int
  public let bitsPerComponent: Swift.Int
  public let opaqueBitmapInfo: CoreGraphics.CGBitmapInfo
  public let transparentBitmapInfo: CoreGraphics.CGBitmapInfo
  public let colorSpace: CoreGraphics.CGColorSpace
  public func bytesPerRow(forWidth width: Swift.Int) -> Swift.Int
}
public class DrawingContext {
  final public let size: CoreFoundation.CGSize
  final public let scale: CoreFoundation.CGFloat
  final public let scaledSize: CoreFoundation.CGSize
  final public let bytesPerRow: Swift.Int
  final public let length: Swift.Int
  public var bytes: Swift.UnsafeMutableRawPointer {
    get
  }
  public func withContext(_ f: (CoreGraphics.CGContext) -> ())
  public func withFlippedContext(_ f: (CoreGraphics.CGContext) -> ())
  public init?(size: CoreFoundation.CGSize, scale: CoreFoundation.CGFloat = 0.0, opaque: Swift.Bool = false, clear: Swift.Bool = false, bytesPerRow: Swift.Int? = nil)
  public func generateImage() -> UIKit.UIImage?
  public func generatePixelBuffer() -> CoreVideo.CVPixelBuffer?
  public func colorAt(_ point: CoreFoundation.CGPoint) -> UIKit.UIColor
  public func blt(_ other: Display.DrawingContext, at: CoreFoundation.CGPoint, mode: Display.DrawingContextBltMode = .Alpha)
  @objc deinit
}
extension UIKit.UIImage {
  public var cvPixelBuffer: CoreVideo.CVPixelBuffer? {
    get
  }
  public var cmSampleBuffer: CoreMedia.CMSampleBuffer? {
    get
  }
}
public enum ParsingError : Swift.Error {
  case Generic
  public static func == (a: Display.ParsingError, b: Display.ParsingError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public func readCGFloat(_ index: inout Swift.UnsafePointer<Swift.UInt8>, end: Swift.UnsafePointer<Swift.UInt8>, separator: Swift.UInt8) throws -> CoreFoundation.CGFloat
public func drawSvgPath(_ context: CoreGraphics.CGContext, path: Swift.StaticString, strokeOnMove: Swift.Bool = false) throws
@objc open class ActionSheetItemNode : AsyncDisplayKit.ASDisplayNode {
  final public let backgroundNode: AsyncDisplayKit.ASDisplayNode
  public var hasSeparator: Swift.Bool
  public var requestLayout: (() -> Swift.Void)?
  public init(theme: Display.ActionSheetControllerTheme)
  open func updateLayout(constrainedSize: CoreFoundation.CGSize, transition: Display.ContainedViewLayoutTransition) -> CoreFoundation.CGSize
  public func updateInternalLayout(_ calculatedSize: CoreFoundation.CGSize, constrainedSize: CoreFoundation.CGSize)
  public func requestLayoutUpdate()
  @objc deinit
}
final public class ActionSheetItemGroup {
  public init(items: [Display.ActionSheetItem], leadingVisibleNodeCount: CoreFoundation.CGFloat? = nil)
  @objc deinit
}
public enum DeviceType {
  case phone
  case tablet
  public static func == (a: Display.DeviceType, b: Display.DeviceType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum DeviceMetrics : Swift.CaseIterable, Swift.Equatable {
  case iPhone4
  case iPhone5
  case iPhone6
  case iPhone6Plus
  case iPhoneX
  case iPhoneXSMax
  case iPhoneXr
  case iPhone12Mini
  case iPhone12
  case iPhone12ProMax
  case iPhone13Mini
  case iPhone13
  case iPhone13Pro
  case iPhone13ProMax
  case iPhone14Pro
  case iPhone14ProZoomed
  case iPhone14ProMax
  case iPhone14ProMaxZoomed
  case iPad
  case iPadMini
  case iPad102Inch
  case iPadPro10Inch
  case iPadPro11Inch
  case iPadPro
  case iPadPro3rdGen
  case iPadMini6thGen
  case unknown(screenSize: CoreFoundation.CGSize, statusBarHeight: CoreFoundation.CGFloat, onScreenNavigationHeight: CoreFoundation.CGFloat?)
  public static var allCases: [Display.DeviceMetrics] {
    get
  }
  public init(screenSize: CoreFoundation.CGSize, scale: CoreFoundation.CGFloat, statusBarHeight: CoreFoundation.CGFloat, onScreenNavigationHeight: CoreFoundation.CGFloat?)
  public var type: Display.DeviceType {
    get
  }
  public var screenCornerRadius: CoreFoundation.CGFloat {
    get
  }
  public func onScreenNavigationHeight(inLandscape: Swift.Bool, systemOnScreenNavigationHeight: CoreFoundation.CGFloat?) -> CoreFoundation.CGFloat?
  public func keyboardHeight(inLandscape: Swift.Bool) -> CoreFoundation.CGFloat
  public var hasTopNotch: Swift.Bool {
    get
  }
  public var hasDynamicIsland: Swift.Bool {
    get
  }
  public var showAppBadge: Swift.Bool {
    get
  }
  public static func == (a: Display.DeviceMetrics, b: Display.DeviceMetrics) -> Swift.Bool
  public typealias AllCases = [Display.DeviceMetrics]
}
public struct ImmediateTextNodeLayoutInfo {
  public let size: CoreFoundation.CGSize
  public let truncated: Swift.Bool
  public let numberOfLines: Swift.Int
  public init(size: CoreFoundation.CGSize, truncated: Swift.Bool, numberOfLines: Swift.Int)
}
@objc @_inheritsConvenienceInitializers public class ImmediateTextNode : Display.TextNode {
  public var attributedText: Foundation.NSAttributedString?
  public var textAlignment: UIKit.NSTextAlignment
  public var verticalAlignment: Display.TextVerticalAlignment
  public var truncationType: CoreText.CTLineTruncationType
  public var maximumNumberOfLines: Swift.Int
  public var lineSpacing: CoreFoundation.CGFloat
  public var insets: UIKit.UIEdgeInsets
  public var textShadowColor: UIKit.UIColor?
  public var textStroke: (UIKit.UIColor, CoreFoundation.CGFloat)?
  public var cutout: Display.TextNodeCutout?
  public var displaySpoilers: Swift.Bool
  public var truncationMode: UIKit.NSLineBreakMode {
    get
    set(value)
  }
  public var linkHighlightColor: UIKit.UIColor?
  public var trailingLineWidth: CoreFoundation.CGFloat?
  public var highlightAttributeAction: (([Foundation.NSAttributedString.Key : Any]) -> Foundation.NSAttributedString.Key?)? {
    get
    set
  }
  public var tapAttributeAction: (([Foundation.NSAttributedString.Key : Any], Swift.Int) -> Swift.Void)?
  public var longTapAttributeAction: (([Foundation.NSAttributedString.Key : Any], Swift.Int) -> Swift.Void)?
  public func makeCopy() -> Display.TextNode
  public func updateLayout(_ constrainedSize: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  public func updateLayoutInfo(_ constrainedSize: CoreFoundation.CGSize) -> Display.ImmediateTextNodeLayoutInfo
  public func updateLayoutFullInfo(_ constrainedSize: CoreFoundation.CGSize) -> Display.TextNodeLayout
  public func redrawIfPossible()
  @objc override dynamic open func didLoad()
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class ASTextNode : Display.ImmediateTextNode {
  override public var attributedText: Foundation.NSAttributedString? {
    get
    set
  }
  @objc override dynamic public init()
  @objc override dynamic public func calculateSizeThatFits(_ constrainedSize: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class ImmediateTextView : Display.TextView {
  @_Concurrency.MainActor(unsafe) public var attributedText: Foundation.NSAttributedString?
  @_Concurrency.MainActor(unsafe) public var textAlignment: UIKit.NSTextAlignment
  @_Concurrency.MainActor(unsafe) public var verticalAlignment: Display.TextVerticalAlignment
  @_Concurrency.MainActor(unsafe) public var truncationType: CoreText.CTLineTruncationType
  @_Concurrency.MainActor(unsafe) public var maximumNumberOfLines: Swift.Int
  @_Concurrency.MainActor(unsafe) public var lineSpacing: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) public var insets: UIKit.UIEdgeInsets
  @_Concurrency.MainActor(unsafe) public var textShadowColor: UIKit.UIColor?
  @_Concurrency.MainActor(unsafe) public var textStroke: (UIKit.UIColor, CoreFoundation.CGFloat)?
  @_Concurrency.MainActor(unsafe) public var cutout: Display.TextNodeCutout?
  @_Concurrency.MainActor(unsafe) public var displaySpoilers: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var truncationMode: UIKit.NSLineBreakMode {
    get
    set(value)
  }
  @_Concurrency.MainActor(unsafe) public var linkHighlightColor: UIKit.UIColor?
  @_Concurrency.MainActor(unsafe) public var trailingLineWidth: CoreFoundation.CGFloat?
  @_Concurrency.MainActor(unsafe) public var highlightAttributeAction: (([Foundation.NSAttributedString.Key : Any]) -> Foundation.NSAttributedString.Key?)? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var tapAttributeAction: (([Foundation.NSAttributedString.Key : Any], Swift.Int) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) public var longTapAttributeAction: (([Foundation.NSAttributedString.Key : Any], Swift.Int) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) public func updateLayout(_ constrainedSize: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  @_Concurrency.MainActor(unsafe) public func updateLayoutInfo(_ constrainedSize: CoreFoundation.CGSize) -> Display.ImmediateTextNodeLayoutInfo
  @_Concurrency.MainActor(unsafe) public func updateLayoutFullInfo(_ constrainedSize: CoreFoundation.CGSize) -> Display.TextNodeLayout
  @_Concurrency.MainActor(unsafe) public func redrawIfPossible()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers open class ListViewAccessoryItemNode : AsyncDisplayKit.ASDisplayNode {
  @objc override dynamic open func layout()
  open func updateLayout(size: CoreFoundation.CGSize, leftInset: CoreFoundation.CGFloat, rightInset: CoreFoundation.CGFloat)
  @objc override dynamic public init()
  @objc override dynamic public init(viewBlock: @escaping AsyncDisplayKit.ASDisplayNodeViewBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc override dynamic public init(layerBlock: @escaping AsyncDisplayKit.ASDisplayNodeLayerBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc deinit
}
public enum ActionSheetCheckboxStyle {
  case `default`
  case alignRight
  public static func == (a: Display.ActionSheetCheckboxStyle, b: Display.ActionSheetCheckboxStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class ActionSheetCheckboxItem : Display.ActionSheetItem {
  final public let title: Swift.String
  final public let label: Swift.String
  final public let value: Swift.Bool
  final public let style: Display.ActionSheetCheckboxStyle
  final public let action: (Swift.Bool) -> Swift.Void
  public init(title: Swift.String, label: Swift.String, value: Swift.Bool, style: Display.ActionSheetCheckboxStyle = .default, action: @escaping (Swift.Bool) -> Swift.Void)
  public func node(theme: Display.ActionSheetControllerTheme) -> Display.ActionSheetItemNode
  public func updateNode(_ node: Display.ActionSheetItemNode)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class ActionSheetCheckboxItemNode : Display.ActionSheetItemNode {
  override public init(theme: Display.ActionSheetControllerTheme)
  override public func updateLayout(constrainedSize: CoreFoundation.CGSize, transition: Display.ContainedViewLayoutTransition) -> CoreFoundation.CGSize
  @objc deinit
}
public protocol ActionSheetGroupOverlayNode : AsyncDisplayKit.ASDisplayNode {
  func updateLayout(size: CoreFoundation.CGSize, transition: Display.ContainedViewLayoutTransition)
}
@objc @_Concurrency.MainActor(unsafe) open class ActionSheetController : Display.ViewController, Display.PresentableController, Display.StandalonePresentableController, Display.KeyShortcutResponder {
  @_Concurrency.MainActor(unsafe) public var theme: Display.ActionSheetControllerTheme {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var dismissed: ((Swift.Bool) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) public init(theme: Display.ActionSheetControllerTheme, allowInputInset: Swift.Bool = false)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) public func dismissAnimated()
  @_Concurrency.MainActor(unsafe) override open func loadDisplayNode()
  @_Concurrency.MainActor(unsafe) override open func containerLayoutUpdated(_ layout: Display.ContainerViewLayout, transition: Display.ContainedViewLayoutTransition)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public func viewDidAppear(completion: @escaping () -> Swift.Void)
  @_Concurrency.MainActor(unsafe) public func setItemGroups(_ groups: [Display.ActionSheetItemGroup])
  @_Concurrency.MainActor(unsafe) public func updateItem(groupIndex: Swift.Int, itemIndex: Swift.Int, _ f: (Display.ActionSheetItem) -> Display.ActionSheetItem)
  @_Concurrency.MainActor(unsafe) public func setItemGroupOverlayNode(groupIndex: Swift.Int, node: Display.ActionSheetGroupOverlayNode)
  @_Concurrency.MainActor(unsafe) public var keyShortcuts: [Display.KeyShortcut] {
    get
  }
  @objc deinit
}
public typealias ListViewTransaction = (@escaping () -> Swift.Void) -> Swift.Void
final public class ListViewTransactionQueue {
  final public var transactionCompleted: () -> Swift.Void
  public init()
  final public func addTransaction(_ transaction: @escaping Display.ListViewTransaction)
  @objc deinit
}
@objc public class DisplayLinkDispatcher : ObjectiveC.NSObject {
  public init(limit: Swift.Int = 0)
  public func dispatch(f: @escaping () -> Swift.Void)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers open class AlertContentNode : AsyncDisplayKit.ASDisplayNode {
  open var requestLayout: ((Display.ContainedViewLayoutTransition) -> Swift.Void)?
  open var dismissOnOutsideTap: Swift.Bool {
    get
  }
  open func updateLayout(size: CoreFoundation.CGSize, transition: Display.ContainedViewLayoutTransition) -> CoreFoundation.CGSize
  open func updateTheme(_ theme: Display.AlertControllerTheme)
  open func performHighlightedAction()
  open func decreaseHighlightedIndex()
  open func increaseHighlightedIndex()
  @objc override dynamic public init()
  @objc override dynamic public init(viewBlock: @escaping AsyncDisplayKit.ASDisplayNodeViewBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc override dynamic public init(layerBlock: @escaping AsyncDisplayKit.ASDisplayNodeLayerBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc deinit
}
public struct TextRangeRectEdge : Swift.Equatable {
  public var x: CoreFoundation.CGFloat
  public var y: CoreFoundation.CGFloat
  public var height: CoreFoundation.CGFloat
  public init(x: CoreFoundation.CGFloat, y: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat)
  public static func == (a: Display.TextRangeRectEdge, b: Display.TextRangeRectEdge) -> Swift.Bool
}
public enum TextNodeCutoutPosition {
  case TopLeft
  case TopRight
  case BottomRight
  public static func == (a: Display.TextNodeCutoutPosition, b: Display.TextNodeCutoutPosition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct TextNodeCutout : Swift.Equatable {
  public var topLeft: CoreFoundation.CGSize?
  public var topRight: CoreFoundation.CGSize?
  public var bottomRight: CoreFoundation.CGSize?
  public init(topLeft: CoreFoundation.CGSize? = nil, topRight: CoreFoundation.CGSize? = nil, bottomRight: CoreFoundation.CGSize? = nil)
  public static func == (a: Display.TextNodeCutout, b: Display.TextNodeCutout) -> Swift.Bool
}
public enum TextVerticalAlignment {
  case top
  case middle
  case bottom
  public static func == (a: Display.TextVerticalAlignment, b: Display.TextVerticalAlignment) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class TextNodeLayoutArguments {
  final public let attributedString: Foundation.NSAttributedString?
  final public let backgroundColor: UIKit.UIColor?
  final public let minimumNumberOfLines: Swift.Int
  final public let maximumNumberOfLines: Swift.Int
  final public let truncationType: CoreText.CTLineTruncationType
  final public let constrainedSize: CoreFoundation.CGSize
  final public let alignment: UIKit.NSTextAlignment
  final public let verticalAlignment: Display.TextVerticalAlignment
  final public let lineSpacing: CoreFoundation.CGFloat
  final public let cutout: Display.TextNodeCutout?
  final public let insets: UIKit.UIEdgeInsets
  final public let lineColor: UIKit.UIColor?
  final public let textShadowColor: UIKit.UIColor?
  final public let textStroke: (UIKit.UIColor, CoreFoundation.CGFloat)?
  final public let displaySpoilers: Swift.Bool
  final public let displayEmbeddedItemsUnderSpoilers: Swift.Bool
  public init(attributedString: Foundation.NSAttributedString?, backgroundColor: UIKit.UIColor? = nil, minimumNumberOfLines: Swift.Int = 0, maximumNumberOfLines: Swift.Int, truncationType: CoreText.CTLineTruncationType, constrainedSize: CoreFoundation.CGSize, alignment: UIKit.NSTextAlignment = .natural, verticalAlignment: Display.TextVerticalAlignment = .top, lineSpacing: CoreFoundation.CGFloat = 0.12, cutout: Display.TextNodeCutout? = nil, insets: UIKit.UIEdgeInsets = UIEdgeInsets(), lineColor: UIKit.UIColor? = nil, textShadowColor: UIKit.UIColor? = nil, textStroke: (UIKit.UIColor, CoreFoundation.CGFloat)? = nil, displaySpoilers: Swift.Bool = false, displayEmbeddedItemsUnderSpoilers: Swift.Bool = false)
  final public func withAttributedString(_ attributedString: Foundation.NSAttributedString?) -> Display.TextNodeLayoutArguments
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers final public class TextNodeLayout : ObjectiveC.NSObject {
  final public class EmbeddedItem : Swift.Equatable {
    final public let range: Foundation.NSRange
    final public let rect: CoreFoundation.CGRect
    final public let value: Swift.AnyHashable
    final public let textColor: UIKit.UIColor
    public init(range: Foundation.NSRange, rect: CoreFoundation.CGRect, value: Swift.AnyHashable, textColor: UIKit.UIColor)
    public static func == (lhs: Display.TextNodeLayout.EmbeddedItem, rhs: Display.TextNodeLayout.EmbeddedItem) -> Swift.Bool
    @objc deinit
  }
  final public let attributedString: Foundation.NSAttributedString?
  final public let insets: UIKit.UIEdgeInsets
  final public let size: CoreFoundation.CGSize
  final public let rawTextSize: CoreFoundation.CGSize
  final public let truncated: Swift.Bool
  final public let hasRTL: Swift.Bool
  final public let spoilers: [(Foundation.NSRange, CoreFoundation.CGRect)]
  final public let spoilerWords: [(Foundation.NSRange, CoreFoundation.CGRect)]
  final public let embeddedItems: [Display.TextNodeLayout.EmbeddedItem]
  final public func areLinesEqual(to other: Display.TextNodeLayout) -> Swift.Bool
  final public var numberOfLines: Swift.Int {
    get
  }
  final public var trailingLineWidth: CoreFoundation.CGFloat {
    get
  }
  final public var trailingLineIsRTL: Swift.Bool {
    get
  }
  final public func attributesAtPoint(_ point: CoreFoundation.CGPoint, orNearest: Swift.Bool) -> (Swift.Int, [Foundation.NSAttributedString.Key : Any])?
  final public func linesRects() -> [CoreFoundation.CGRect]
  final public func textRangesRects(text: Swift.String) -> [[CoreFoundation.CGRect]]
  final public func attributeSubstring(name: Swift.String, index: Swift.Int) -> (Swift.String, Swift.String)?
  final public func allAttributeRects(name: Swift.String) -> [(Any, CoreFoundation.CGRect)]
  final public func lineAndAttributeRects(name: Swift.String, at index: Swift.Int) -> [(CoreFoundation.CGRect, CoreFoundation.CGRect)]?
  final public func rangeRects(in range: Foundation.NSRange) -> (rects: [CoreFoundation.CGRect], start: Display.TextRangeRectEdge, end: Display.TextRangeRectEdge)?
  @objc deinit
}
@objc final public class TextAccessibilityOverlayNode : AsyncDisplayKit.ASDisplayNode {
  final public var cachedLayout: Display.TextNodeLayout? {
    get
    set
  }
  final public var openUrl: ((Swift.String) -> Swift.Void)?
  @objc override dynamic public init()
  @objc override final public func didLoad()
  @objc override final public func hitTest(_ point: CoreFoundation.CGPoint, with event: UIKit.UIEvent?) -> UIKit.UIView?
  @objc deinit
}
@objc open class TextNode : AsyncDisplayKit.ASDisplayNode {
  public var cachedLayout: Display.TextNodeLayout? {
    get
  }
  @objc override dynamic public init()
  @objc override dynamic open func didLoad()
  public func attributesAtPoint(_ point: CoreFoundation.CGPoint, orNearest: Swift.Bool = false) -> (Swift.Int, [Foundation.NSAttributedString.Key : Any])?
  public func textRangesRects(text: Swift.String) -> [[CoreFoundation.CGRect]]
  public func attributeSubstring(name: Swift.String, index: Swift.Int) -> (Swift.String, Swift.String)?
  public func attributeRects(name: Swift.String, at index: Swift.Int) -> [CoreFoundation.CGRect]?
  public func rangeRects(in range: Foundation.NSRange) -> (rects: [CoreFoundation.CGRect], start: Display.TextRangeRectEdge, end: Display.TextRangeRectEdge)?
  public func lineAndAttributeRects(name: Swift.String, at index: Swift.Int) -> [(CoreFoundation.CGRect, CoreFoundation.CGRect)]?
  @objc override dynamic public func drawParameters(forAsyncLayer layer: AsyncDisplayKit._ASDisplayLayer) -> ObjectiveC.NSObjectProtocol?
  @objc override dynamic public class func draw(_ bounds: CoreFoundation.CGRect, withParameters parameters: Any?, isCancelled: () -> Swift.Bool, isRasterizing: Swift.Bool)
  public static func asyncLayout(_ maybeNode: Display.TextNode?) -> (Display.TextNodeLayoutArguments) -> (Display.TextNodeLayout, () -> Display.TextNode)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class TextView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public var cachedLayout: Display.TextNodeLayout? {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) public func attributesAtPoint(_ point: CoreFoundation.CGPoint, orNearest: Swift.Bool = false) -> (Swift.Int, [Foundation.NSAttributedString.Key : Any])?
  @_Concurrency.MainActor(unsafe) public func textRangesRects(text: Swift.String) -> [[CoreFoundation.CGRect]]
  @_Concurrency.MainActor(unsafe) public func attributeSubstring(name: Swift.String, index: Swift.Int) -> (Swift.String, Swift.String)?
  @_Concurrency.MainActor(unsafe) public func attributeRects(name: Swift.String, at index: Swift.Int) -> [CoreFoundation.CGRect]?
  @_Concurrency.MainActor(unsafe) public func rangeRects(in range: Foundation.NSRange) -> (rects: [CoreFoundation.CGRect], start: Display.TextRangeRectEdge, end: Display.TextRangeRectEdge)?
  @_Concurrency.MainActor(unsafe) public func lineAndAttributeRects(name: Swift.String, at index: Swift.Int) -> [(CoreFoundation.CGRect, CoreFoundation.CGRect)]?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func draw(_ rect: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) public static func asyncLayout(_ maybeView: Display.TextView?) -> (Display.TextNodeLayoutArguments) -> (Display.TextNodeLayout, () -> Display.TextView)
  @objc deinit
}
public enum TapLongTapOrDoubleTapGesture {
  case tap
  case doubleTap
  case longTap
  case secondaryTap
  case hold
  public static func == (a: Display.TapLongTapOrDoubleTapGesture, b: Display.TapLongTapOrDoubleTapGesture) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum TapLongTapOrDoubleTapGestureRecognizerAction {
  case waitForDoubleTap
  case waitForSingleTap
  case waitForHold(timeout: Swift.Double, acceptTap: Swift.Bool)
  case fail
  case keepWithSingleTap
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class TapLongTapOrDoubleTapGestureRecognizer : UIKit.UIGestureRecognizer, UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor(unsafe) final public var lastRecognizedGestureAndLocation: (Display.TapLongTapOrDoubleTapGesture, CoreFoundation.CGPoint)? {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var tapActionAtPoint: ((CoreFoundation.CGPoint) -> Display.TapLongTapOrDoubleTapGestureRecognizerAction)?
  @_Concurrency.MainActor(unsafe) final public var longTap: ((CoreFoundation.CGPoint, Display.TapLongTapOrDoubleTapGestureRecognizer) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var secondaryTap: ((CoreFoundation.CGPoint, Display.TapLongTapOrDoubleTapGestureRecognizer) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var externalUpdated: ((UIKit.UIView?, CoreFoundation.CGPoint) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var externalEnded: (((UIKit.UIView?, CoreFoundation.CGPoint)?) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var highlight: ((CoreFoundation.CGPoint?) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var hapticFeedback: Display.HapticFeedback?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(target: Any?, action: ObjectiveC.Selector?)
  @_Concurrency.MainActor(unsafe) @objc final public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override final public func reset()
  @_Concurrency.MainActor(unsafe) final public func cancel()
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesMoved(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @_Concurrency.MainActor(unsafe) @objc override final public func touchesCancelled(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent)
  @objc deinit
}
public func horizontalContainerFillingSizeForLayout(layout: Display.ContainerViewLayout, sideInset: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
public protocol NavigationBarTitleView {
  func animateLayoutTransition()
  func updateLayout(size: CoreFoundation.CGSize, clearBounds: CoreFoundation.CGRect, transition: Display.ContainedViewLayoutTransition)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class EditableTextNode : AsyncDisplayKit.ASEditableTextNode {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var keyboardAppearance: UIKit.UIKeyboardAppearance {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) public var isRTL: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(textKitComponents: AsyncDisplayKit.ASTextKitComponents, placeholderTextKitComponents: AsyncDisplayKit.ASTextKitComponents)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(viewBlock: @escaping AsyncDisplayKit.ASDisplayNodeViewBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(layerBlock: @escaping AsyncDisplayKit.ASDisplayNodeLayerBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc deinit
}
extension UIKit.UITextView {
  @_Concurrency.MainActor(unsafe) public var numberOfLines: Swift.Int {
    get
  }
}
public enum LegacyPresentedControllerPresentation {
  case custom
  case modal
  public static func == (a: Display.LegacyPresentedControllerPresentation, b: Display.LegacyPresentedControllerPresentation) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_Concurrency.MainActor(unsafe) open class LegacyPresentedController : Display.ViewController {
  @_Concurrency.MainActor(unsafe) public init(legacyController: UIKit.UIViewController, presentation: Display.LegacyPresentedControllerPresentation)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) override open func loadDisplayNode()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewWillDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewDidDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) override open func containerLayoutUpdated(_ layout: Display.ContainerViewLayout, transition: Display.ContainedViewLayoutTransition)
  @_Concurrency.MainActor(unsafe) override open func dismiss(completion: (() -> Swift.Void)? = nil)
  @objc deinit
}
public enum TextAlertActionType {
  case genericAction
  case defaultAction
  case destructiveAction
  public static func == (a: Display.TextAlertActionType, b: Display.TextAlertActionType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct TextAlertAction {
  public let type: Display.TextAlertActionType
  public let title: Swift.String
  public let action: () -> Swift.Void
  public init(type: Display.TextAlertActionType, title: Swift.String, action: @escaping () -> Swift.Void)
}
@objc final public class TextAlertContentActionNode : Display.HighlightableButtonNode {
  public init(theme: Display.AlertControllerTheme, action: Display.TextAlertAction)
  @objc override final public func didLoad()
  final public var actionEnabled: Swift.Bool {
    get
    set
  }
  final public func updateTheme(_ theme: Display.AlertControllerTheme)
  @objc override final public func layout()
  @objc deinit
}
public enum TextAlertContentActionLayout {
  case horizontal
  case vertical
  public static func == (a: Display.TextAlertContentActionLayout, b: Display.TextAlertContentActionLayout) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc final public class TextAlertContentNode : Display.AlertContentNode {
  override final public var dismissOnOutsideTap: Swift.Bool {
    get
  }
  final public var textAttributeAction: (Foundation.NSAttributedString.Key, (Any) -> Swift.Void)? {
    get
    set
  }
  public init(theme: Display.AlertControllerTheme, title: Foundation.NSAttributedString?, text: Foundation.NSAttributedString, actions: [Display.TextAlertAction], actionLayout: Display.TextAlertContentActionLayout, dismissOnOutsideTap: Swift.Bool)
  override final public func decreaseHighlightedIndex()
  override final public func increaseHighlightedIndex()
  override final public func performHighlightedAction()
  override final public func updateTheme(_ theme: Display.AlertControllerTheme)
  override final public func updateLayout(size: CoreFoundation.CGSize, transition: Display.ContainedViewLayoutTransition) -> CoreFoundation.CGSize
  @objc deinit
}
public func textAlertController(theme: Display.AlertControllerTheme, title: Foundation.NSAttributedString?, text: Foundation.NSAttributedString, actions: [Display.TextAlertAction], actionLayout: Display.TextAlertContentActionLayout = .horizontal, dismissOnOutsideTap: Swift.Bool = true) -> Display.AlertController
public func standardTextAlertController(theme: Display.AlertControllerTheme, title: Swift.String?, text: Swift.String, actions: [Display.TextAlertAction], actionLayout: Display.TextAlertContentActionLayout = .horizontal, allowInputInset: Swift.Bool = true, parseMarkdown: Swift.Bool = false, dismissOnOutsideTap: Swift.Bool = true) -> Display.AlertController
@objc final public class NavigationBarBadgeNode : AsyncDisplayKit.ASDisplayNode {
  public init(fillColor: UIKit.UIColor, strokeColor: UIKit.UIColor, textColor: UIKit.UIColor)
  @objc override final public func calculateSizeThatFits(_ constrainedSize: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  @objc deinit
}
public protocol StandalonePresentableController : Display.ViewController {
}
public enum ViewControllerPresentationAnimation {
  case none
  case modalSheet
  public static func == (a: Display.ViewControllerPresentationAnimation, b: Display.ViewControllerPresentationAnimation) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ViewControllerSupportedOrientations : Swift.Equatable {
  public var regularSize: UIKit.UIInterfaceOrientationMask
  public var compactSize: UIKit.UIInterfaceOrientationMask
  public init(regularSize: UIKit.UIInterfaceOrientationMask, compactSize: UIKit.UIInterfaceOrientationMask)
  public func intersection(_ other: Display.ViewControllerSupportedOrientations) -> Display.ViewControllerSupportedOrientations
  public static func == (a: Display.ViewControllerSupportedOrientations, b: Display.ViewControllerSupportedOrientations) -> Swift.Bool
}
open class ViewControllerPresentationArguments {
  final public let presentationAnimation: Display.ViewControllerPresentationAnimation
  final public let completion: (() -> Swift.Void)?
  public init(presentationAnimation: Display.ViewControllerPresentationAnimation, completion: (() -> Swift.Void)? = nil)
  @objc deinit
}
public enum ViewControllerNavigationPresentation {
  case `default`
  case master
  case modal
  case flatModal
  case standaloneModal
  case modalInLargeLayout
  public static func == (a: Display.ViewControllerNavigationPresentation, b: Display.ViewControllerNavigationPresentation) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum TabBarItemContextActionType {
  case none
  case always
  case whenActive
  public static func == (a: Display.TabBarItemContextActionType, b: Display.TabBarItemContextActionType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol CustomViewControllerNavigationData : AnyObject {
  func combine(summary: Display.CustomViewControllerNavigationDataSummary?) -> Display.CustomViewControllerNavigationDataSummary?
}
public protocol CustomViewControllerNavigationDataSummary : AnyObject {
}
@objc @_Concurrency.MainActor(unsafe) open class ViewController : UIKit.UIViewController, Display.ContainableController {
  public struct NavigationLayout {
    public var navigationFrame: CoreFoundation.CGRect
    public var defaultContentHeight: CoreFoundation.CGFloat
    public init(navigationFrame: CoreFoundation.CGRect, defaultContentHeight: CoreFoundation.CGFloat)
  }
  @_Concurrency.MainActor(unsafe) public var currentlyAppliedLayout: Display.ContainerViewLayout? {
    get
  }
  @_Concurrency.MainActor(unsafe) final public let presentationContext: Display.PresentationContext
  @_Concurrency.MainActor(unsafe) final public var supportedOrientations: Display.ViewControllerSupportedOrientations {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var lockedOrientation: UIKit.UIInterfaceOrientationMask?
  @_Concurrency.MainActor(unsafe) final public var lockOrientation: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var isOpaqueWhenInOverlay: Swift.Bool
  @_Concurrency.MainActor(unsafe) final public var blocksBackgroundWhenInOverlay: Swift.Bool
  @_Concurrency.MainActor(unsafe) final public var acceptsFocusWhenInOverlay: Swift.Bool
  @_Concurrency.MainActor(unsafe) final public var automaticallyControlPresentationContextLayout: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var updateTransitionWhenPresentedAsModal: ((CoreFoundation.CGFloat, Display.ContainedViewLayoutTransition) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) public func requestUpdateParameters()
  @_Concurrency.MainActor(unsafe) public func combinedSupportedOrientations(currentOrientationToLock: UIKit.UIInterfaceOrientationMask) -> Display.ViewControllerSupportedOrientations
  @_Concurrency.MainActor(unsafe) final public var deferScreenEdgeGestures: UIKit.UIRectEdge {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var prefersOnScreenNavigationHidden: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var prefersHomeIndicatorAutoHidden: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) open var navigationPresentation: Display.ViewControllerNavigationPresentation
  @_Concurrency.MainActor(unsafe) open var _presentedInModal: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var presentedOverCoveringView: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var presentationArguments: Any?
  @_Concurrency.MainActor(unsafe) public var tabBarItemDebugTapAction: (() -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) public var modalStyleOverlayTransitionFactor: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor(unsafe) public var modalStyleOverlayTransitionFactorUpdated: ((Display.ContainedViewLayoutTransition) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) public func updateModalStyleOverlayTransitionFactor(_ value: CoreFoundation.CGFloat, transition: Display.ContainedViewLayoutTransition)
  @_Concurrency.MainActor(unsafe) final public var displayNode: AsyncDisplayKit.ASDisplayNode {
    get
    set(value)
  }
  @_Concurrency.MainActor(unsafe) final public var isNodeLoaded: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) final public let statusBar: Display.StatusBar
  @_Concurrency.MainActor(unsafe) final public let navigationBar: Display.NavigationBar?
  @_Concurrency.MainActor(unsafe) open var transitionNavigationBar: Display.NavigationBar? {
    get
  }
  @_Concurrency.MainActor(unsafe) public var toolbar: Display.Toolbar? {
    get
  }
  @_Concurrency.MainActor(unsafe) public var displayNavigationBar: Swift.Bool
  @_Concurrency.MainActor(unsafe) open var navigationBarRequiresEntireLayoutUpdate: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) open var hasActiveInput: Swift.Bool
  @_Concurrency.MainActor(unsafe) open var overlayWantsToBeBelowKeyboard: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) public func overlayWantsToBeBelowKeyboardUpdated(transition: Display.ContainedViewLayoutTransition)
  @_Concurrency.MainActor(unsafe) open func navigationLayout(layout: Display.ContainerViewLayout) -> Display.ViewController.NavigationLayout
  @_Concurrency.MainActor(unsafe) open var cleanNavigationHeight: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor(unsafe) open var additionalNavigationBarHeight: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor(unsafe) public var additionalSideInsets: UIKit.UIEdgeInsets
  @_Concurrency.MainActor(unsafe) open var ready: SwiftSignalKit.Promise<Swift.Bool> {
    get
  }
  @_Concurrency.MainActor(unsafe) public var scrollToTop: (() -> Swift.Void)? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var scrollToTopWithTabBar: (() -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) public var longTapWithTabBar: (() -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) public var customPresentPreviewingController: ((Display.ViewController, AsyncDisplayKit.ASDisplayNode) -> Display.ViewController?)?
  @_Concurrency.MainActor(unsafe) open func updateNavigationCustomData(_ data: Any?, progress: CoreFoundation.CGFloat, transition: Display.ContainedViewLayoutTransition)
  @_Concurrency.MainActor(unsafe) open var customData: Any? {
    get
  }
  @_Concurrency.MainActor(unsafe) open var customNavigationData: Display.CustomViewControllerNavigationData? {
    get
  }
  @_Concurrency.MainActor(unsafe) open var customNavigationDataSummary: Display.CustomViewControllerNavigationDataSummary?
  @_Concurrency.MainActor(unsafe) public var isInFocus: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) open func inFocusUpdated(isInFocus: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public var attemptNavigation: (@escaping () -> Swift.Void) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) open func preferredContentSizeForLayout(_ layout: Display.ContainerViewLayout) -> CoreFoundation.CGSize?
  @_Concurrency.MainActor(unsafe) open func didAppearInContextPreview()
  @_Concurrency.MainActor(unsafe) public init(navigationBarPresentationData: Display.NavigationBarPresentationData?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(coder aDecoder: Foundation.NSCoder)
  @objc deinit
  @_Concurrency.MainActor(unsafe) open func updateNavigationBarLayout(_ layout: Display.ContainerViewLayout, transition: Display.ContainedViewLayoutTransition)
  @_Concurrency.MainActor(unsafe) public func applyNavigationBarLayout(_ layout: Display.ContainerViewLayout, navigationLayout: Display.ViewController.NavigationLayout, additionalBackgroundHeight: CoreFoundation.CGFloat, transition: Display.ContainedViewLayoutTransition)
  @_Concurrency.MainActor(unsafe) open func containerLayoutUpdated(_ layout: Display.ContainerViewLayout, transition: Display.ContainedViewLayoutTransition)
  @_Concurrency.MainActor(unsafe) open func updateModalTransition(_ value: CoreFoundation.CGFloat, transition: Display.ContainedViewLayoutTransition)
  @_Concurrency.MainActor(unsafe) open func navigationStackConfigurationUpdated(next: [Display.ViewController])
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func loadView()
  @_Concurrency.MainActor(unsafe) open func loadDisplayNode()
  @_Concurrency.MainActor(unsafe) open func displayNodeDidLoad()
  @_Concurrency.MainActor(unsafe) public func requestLayout(transition: Display.ContainedViewLayoutTransition)
  @_Concurrency.MainActor(unsafe) open func updateToInterfaceOrientation(_ orientation: UIKit.UIInterfaceOrientation)
  @_Concurrency.MainActor(unsafe) public func setDisplayNavigationBar(_ displayNavigationBar: Swift.Bool, transition: Display.ContainedViewLayoutTransition = .immediate)
  @_Concurrency.MainActor(unsafe) public func setNavigationBarPresentationData(_ presentationData: Display.NavigationBarPresentationData, animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public func setStatusBarStyle(_ style: Display.StatusBarStyle, animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func present(_ viewControllerToPresent: UIKit.UIViewController, animated flag: Swift.Bool, completion: (() -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func dismiss(animated flag: Swift.Bool, completion: (() -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) final public var window: Display.WindowHost? {
    get
  }
  @_Concurrency.MainActor(unsafe) public func push(_ controller: Display.ViewController)
  @_Concurrency.MainActor(unsafe) public func replace(with controller: Display.ViewController)
  @_Concurrency.MainActor(unsafe) open func present(_ controller: Display.ViewController, in context: Display.PresentationContextType, with arguments: Any? = nil, blockInteraction: Swift.Bool = false, completion: @escaping () -> Swift.Void = {})
  @_Concurrency.MainActor(unsafe) public func forEachController(_ f: (Display.ContainableController) -> Swift.Bool)
  @_Concurrency.MainActor(unsafe) public func presentInGlobalOverlay(_ controller: Display.ViewController, with arguments: Any? = nil)
  @_Concurrency.MainActor(unsafe) public func addGlobalPortalHostView(sourceView: Display.PortalSourceView)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewWillDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewDidDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) open func viewWillLeaveNavigation()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) open func dismiss(completion: (() -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) final public func navigationNextSibling() -> UIKit.UIViewController?
  @_Concurrency.MainActor(unsafe) public func traceVisibility() -> Swift.Bool
  @_Concurrency.MainActor(unsafe) open func setToolbar(_ toolbar: Display.Toolbar?, transition: Display.ContainedViewLayoutTransition)
  @_Concurrency.MainActor(unsafe) open func toolbarActionSelected(action: Display.ToolbarActionOption)
  @_Concurrency.MainActor(unsafe) open var tabBarItemContextActionType: Display.TabBarItemContextActionType
  @_Concurrency.MainActor(unsafe) open func tabBarItemContextAction(sourceNode: Display.ContextExtractedContentContainingNode, gesture: Display.ContextGesture)
  @_Concurrency.MainActor(unsafe) open func tabBarDisabledAction()
  @_Concurrency.MainActor(unsafe) open func tabBarItemSwipeAction(direction: Display.TabBarItemSwipeDirection)
  @_Concurrency.MainActor(unsafe) open func updatePossibleControllerDropContent(content: Display.NavigationControllerDropContent?)
  @_Concurrency.MainActor(unsafe) open func acceptPossibleControllerDropContent(content: Display.NavigationControllerDropContent) -> Swift.Bool
}
public enum NavigationStatusBarStyle {
  case black
  case white
  public static func == (a: Display.NavigationStatusBarStyle, b: Display.NavigationStatusBarStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class NavigationControllerTheme {
  final public let statusBar: Display.NavigationStatusBarStyle
  final public let navigationBar: Display.NavigationBarTheme
  final public let emptyAreaColor: UIKit.UIColor
  public init(statusBar: Display.NavigationStatusBarStyle, navigationBar: Display.NavigationBarTheme, emptyAreaColor: UIKit.UIColor)
  @objc deinit
}
public struct NavigationAnimationOptions : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  public init()
  public static let removeOnMasterDetails: Display.NavigationAnimationOptions
  public typealias ArrayLiteralElement = Display.NavigationAnimationOptions
  public typealias Element = Display.NavigationAnimationOptions
  public typealias RawValue = Swift.Int
}
public enum NavigationEmptyDetailsBackgoundMode {
  case image(UIKit.UIImage)
  case wallpaper(UIKit.UIImage)
}
public enum NavigationControllerMode {
  case single
  case automaticMasterDetail
  public static func == (a: Display.NavigationControllerMode, b: Display.NavigationControllerMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum MasterDetailLayoutBlackout : Swift.Equatable {
  case master
  case details
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Display.MasterDetailLayoutBlackout, b: Display.MasterDetailLayoutBlackout) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol NavigationControllerDropContentItem : AnyObject {
}
final public class NavigationControllerDropContent {
  final public let position: CoreFoundation.CGPoint
  final public let item: Display.NavigationControllerDropContentItem
  public init(position: CoreFoundation.CGPoint, item: Display.NavigationControllerDropContentItem)
  @objc deinit
}
@objc @_Concurrency.MainActor(unsafe) open class NavigationController : UIKit.UINavigationController, Display.ContainableController, UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor(unsafe) public var isOpaqueWhenInOverlay: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var blocksBackgroundWhenInOverlay: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var updateTransitionWhenPresentedAsModal: ((CoreFoundation.CGFloat, Display.ContainedViewLayoutTransition) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) open var ready: SwiftSignalKit.Promise<Swift.Bool> {
    get
  }
  @_Concurrency.MainActor(unsafe) public var lockOrientation: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var deferScreenEdgeGestures: UIKit.UIRectEdge
  @_Concurrency.MainActor(unsafe) public var prefersOnScreenNavigationHidden: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) public var globalOverlayControllersUpdated: (() -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) public var validLayout: Display.ContainerViewLayout? {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var presentedViewController: UIKit.UIViewController? {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var viewControllers: [UIKit.UIViewController] {
    @objc get
    @objc set(value)
  }
  @_Concurrency.MainActor(unsafe) public var viewControllersSignal: SwiftSignalKit.Signal<[UIKit.UIViewController], SwiftSignalKit.NoError> {
    get
  }
  @_Concurrency.MainActor(unsafe) public var overlayControllersSignal: SwiftSignalKit.Signal<[UIKit.UIViewController], SwiftSignalKit.NoError> {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var topViewController: UIKit.UIViewController? {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) public var displayNode: AsyncDisplayKit.ASDisplayNode {
    get
  }
  @_Concurrency.MainActor(unsafe) public var statusBarHost: Display.StatusBarHost? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public func updateMasterDetailsBlackout(_ blackout: Display.MasterDetailLayoutBlackout?, transition: Display.ContainedViewLayoutTransition)
  @_Concurrency.MainActor(unsafe) public func updateBackgroundDetailsMode(_ mode: Display.NavigationEmptyDetailsBackgoundMode?, transition: Display.ContainedViewLayoutTransition)
  @_Concurrency.MainActor(unsafe) public init(mode: Display.NavigationControllerMode, theme: Display.NavigationControllerTheme, isFlat: Swift.Bool = false, backgroundDetailsMode: Display.NavigationEmptyDetailsBackgoundMode? = nil)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(coder aDecoder: Foundation.NSCoder)
  @objc deinit
  @_Concurrency.MainActor(unsafe) public func combinedSupportedOrientations(currentOrientationToLock: UIKit.UIInterfaceOrientationMask) -> Display.ViewControllerSupportedOrientations
  @_Concurrency.MainActor(unsafe) public func updateTheme(_ theme: Display.NavigationControllerTheme)
  @_Concurrency.MainActor(unsafe) open func preferredContentSizeForLayout(_ layout: Display.ContainerViewLayout) -> CoreFoundation.CGSize?
  @_Concurrency.MainActor(unsafe) public func containerLayoutUpdated(_ layout: Display.ContainerViewLayout, transition: Display.ContainedViewLayoutTransition)
  @_Concurrency.MainActor(unsafe) public func updateModalTransition(_ value: CoreFoundation.CGFloat, transition: Display.ContainedViewLayoutTransition)
  @_Concurrency.MainActor(unsafe) public func updateToInterfaceOrientation(_ orientation: UIKit.UIInterfaceOrientation)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func loadView()
  @_Concurrency.MainActor(unsafe) public func pushViewController(_ controller: Display.ViewController)
  @_Concurrency.MainActor(unsafe) public func pushViewController(_ controller: Display.ViewController, animated: Swift.Bool = true, completion: @escaping () -> Swift.Void)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func pushViewController(_ viewController: UIKit.UIViewController, animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public func replaceTopController(_ controller: Display.ViewController, animated: Swift.Bool, ready: SwiftSignalKit.Promise<Swift.Bool>? = nil)
  @_Concurrency.MainActor(unsafe) public func filterController(_ controller: Display.ViewController, animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public func replaceController(_ controller: Display.ViewController, with other: Display.ViewController, animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public func replaceControllersAndPush(controllers: [UIKit.UIViewController], controller: Display.ViewController, animated: Swift.Bool, options: Display.NavigationAnimationOptions = [], ready: SwiftSignalKit.ValuePromise<Swift.Bool>? = nil, completion: @escaping () -> Swift.Void = {})
  @_Concurrency.MainActor(unsafe) public func replaceControllers(controllers: [UIKit.UIViewController], animated: Swift.Bool, options: Display.NavigationAnimationOptions = [], ready: SwiftSignalKit.ValuePromise<Swift.Bool>? = nil, completion: @escaping () -> Swift.Void = {})
  @_Concurrency.MainActor(unsafe) public func replaceAllButRootController(_ controller: Display.ViewController, animated: Swift.Bool, animationOptions: Display.NavigationAnimationOptions = [], ready: SwiftSignalKit.ValuePromise<Swift.Bool>? = nil, completion: @escaping () -> Swift.Void = {})
  @_Concurrency.MainActor(unsafe) public func popToRoot(animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func popToViewController(_ viewController: UIKit.UIViewController, animated: Swift.Bool) -> [UIKit.UIViewController]?
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func popViewController(animated: Swift.Bool) -> UIKit.UIViewController?
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func setViewControllers(_ viewControllers: [UIKit.UIViewController], animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public var _keepModalDismissProgress: Swift.Bool
  @_Concurrency.MainActor(unsafe) public func presentOverlay(controller: Display.ViewController, inGlobal: Swift.Bool = false, blockInteraction: Swift.Bool = false)
  @_Concurrency.MainActor(unsafe) public func updatePossibleControllerDropContent(content: Display.NavigationControllerDropContent?)
  @_Concurrency.MainActor(unsafe) public func acceptPossibleControllerDropContent(content: Display.NavigationControllerDropContent) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func dismiss(animated flag: Swift.Bool, completion: (() -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) final public var currentWindow: Display.WindowHost? {
    get
  }
  @_Concurrency.MainActor(unsafe) public func requestLayout(transition: Display.ContainedViewLayoutTransition)
  @_Concurrency.MainActor(unsafe) public func setForceInCallStatusBar(_ forceInCallStatusBar: Display.CallStatusBarNode?, transition: Display.ContainedViewLayoutTransition = .animated(duration: 0.3, curve: .easeInOut))
  @_Concurrency.MainActor(unsafe) public var overlayControllers: [Display.ViewController] {
    get
  }
  @_Concurrency.MainActor(unsafe) public var globalOverlayControllers: [Display.ViewController] {
    get
  }
}
public protocol StatusBarHost {
  var statusBarFrame: CoreFoundation.CGRect { get }
  var statusBarStyle: UIKit.UIStatusBarStyle { get set }
  var keyboardWindow: UIKit.UIWindow? { get }
  var keyboardView: UIKit.UIView? { get }
  var isApplicationInForeground: Swift.Bool { get }
  func setStatusBarStyle(_ style: UIKit.UIStatusBarStyle, animated: Swift.Bool)
  func setStatusBarHidden(_ value: Swift.Bool, animated: Swift.Bool)
  var shouldChangeStatusBarStyle: ((UIKit.UIStatusBarStyle) -> Swift.Bool)? { get set }
}
public enum PointerStyle {
  case `default`
  case insetRectangle(CoreFoundation.CGFloat, CoreFoundation.CGFloat)
  case rectangle(CoreFoundation.CGSize)
  case circle(CoreFoundation.CGFloat?)
  case caret
  case lift
  case hover
}
final public class PointerInteraction {
  convenience public init(node: AsyncDisplayKit.ASDisplayNode, style: Display.PointerStyle = .default, willEnter: @escaping () -> Swift.Void = {}, willExit: @escaping () -> Swift.Void = {})
  public init(view: UIKit.UIView, customInteractionView: UIKit.UIView? = nil, style: Display.PointerStyle = .default, willEnter: @escaping () -> Swift.Void = {}, willExit: @escaping () -> Swift.Void = {})
  @objc deinit
}
@objc @_inheritsConvenienceInitializers open class ContextControllerSourceNode : Display.ContextReferenceContentNode {
  public var contextGesture: Display.ContextGesture? {
    get
  }
  public var isGestureEnabled: Swift.Bool {
    get
    set
  }
  public var beginDelay: Swift.Double {
    get
    set
  }
  public var animateScale: Swift.Bool
  public var activated: ((Display.ContextGesture, CoreFoundation.CGPoint) -> Swift.Void)?
  public var shouldBegin: ((CoreFoundation.CGPoint) -> Swift.Bool)?
  public var customActivationProgress: ((CoreFoundation.CGFloat, Display.ContextGestureTransition) -> Swift.Void)?
  weak public var additionalActivationProgressLayer: QuartzCore.CALayer?
  public var targetNodeForActivationProgress: AsyncDisplayKit.ASDisplayNode?
  public var targetNodeForActivationProgressContentRect: CoreFoundation.CGRect?
  public func cancelGesture()
  @objc override dynamic open func didLoad()
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class ContextControllerSourceView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public var contextGesture: Display.ContextGesture? {
    get
  }
  @_Concurrency.MainActor(unsafe) public var isGestureEnabled: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var beginDelay: Swift.Double {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var animateScale: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var activated: ((Display.ContextGesture, CoreFoundation.CGPoint) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) public var shouldBegin: ((CoreFoundation.CGPoint) -> Swift.Bool)?
  @_Concurrency.MainActor(unsafe) public var customActivationProgress: ((CoreFoundation.CGFloat, Display.ContextGestureTransition) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) weak public var additionalActivationProgressLayer: QuartzCore.CALayer?
  @_Concurrency.MainActor(unsafe) public var targetNodeForActivationProgress: AsyncDisplayKit.ASDisplayNode?
  @_Concurrency.MainActor(unsafe) public var targetViewForActivationProgress: UIKit.UIView?
  @_Concurrency.MainActor(unsafe) weak public var targetLayerForActivationProgress: QuartzCore.CALayer?
  @_Concurrency.MainActor(unsafe) public var targetNodeForActivationProgressContentRect: CoreFoundation.CGRect?
  @_Concurrency.MainActor(unsafe) public var useSublayerTransformForActivation: Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) public func cancelGesture()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers open class SparseNode : AsyncDisplayKit.ASDisplayNode {
  @objc override dynamic public func hitTest(_ point: CoreFoundation.CGPoint, with event: UIKit.UIEvent?) -> UIKit.UIView?
  @objc override dynamic public init()
  @objc override dynamic public init(viewBlock: @escaping AsyncDisplayKit.ASDisplayNodeViewBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc override dynamic public init(layerBlock: @escaping AsyncDisplayKit.ASDisplayNodeLayerBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class SparseContainerView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func hitTest(_ point: CoreFoundation.CGPoint, with event: UIKit.UIEvent?) -> UIKit.UIView?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
final public class NavigationBarTheme {
  public static func generateBackArrowImage(color: UIKit.UIColor) -> UIKit.UIImage?
  final public let buttonColor: UIKit.UIColor
  final public let disabledButtonColor: UIKit.UIColor
  final public let primaryTextColor: UIKit.UIColor
  final public let backgroundColor: UIKit.UIColor
  final public let enableBackgroundBlur: Swift.Bool
  final public let separatorColor: UIKit.UIColor
  final public let badgeBackgroundColor: UIKit.UIColor
  final public let badgeStrokeColor: UIKit.UIColor
  final public let badgeTextColor: UIKit.UIColor
  public init(buttonColor: UIKit.UIColor, disabledButtonColor: UIKit.UIColor, primaryTextColor: UIKit.UIColor, backgroundColor: UIKit.UIColor, enableBackgroundBlur: Swift.Bool, separatorColor: UIKit.UIColor, badgeBackgroundColor: UIKit.UIColor, badgeStrokeColor: UIKit.UIColor, badgeTextColor: UIKit.UIColor)
  final public func withUpdatedBackgroundColor(_ color: UIKit.UIColor) -> Display.NavigationBarTheme
  final public func withUpdatedSeparatorColor(_ color: UIKit.UIColor) -> Display.NavigationBarTheme
  @objc deinit
}
final public class NavigationBarStrings {
  final public let back: Swift.String
  final public let close: Swift.String
  public init(back: Swift.String, close: Swift.String)
  @objc deinit
}
final public class NavigationBarPresentationData {
  final public let theme: Display.NavigationBarTheme
  final public let strings: Display.NavigationBarStrings
  public init(theme: Display.NavigationBarTheme, strings: Display.NavigationBarStrings)
  @objc deinit
}
public enum NavigationPreviousAction : Swift.Equatable {
  case item(UIKit.UINavigationItem)
  case close
  public static func == (lhs: Display.NavigationPreviousAction, rhs: Display.NavigationPreviousAction) -> Swift.Bool
}
@objc final public class NavigationBackgroundNode : AsyncDisplayKit.ASDisplayNode {
  final public var backgroundCornerRadius: CoreFoundation.CGFloat {
    get
  }
  public init(color: UIKit.UIColor, enableBlur: Swift.Bool = true)
  @objc override final public func didLoad()
  final public func updateColor(color: UIKit.UIColor, enableBlur: Swift.Bool? = nil, forceKeepBlur: Swift.Bool = false, transition: Display.ContainedViewLayoutTransition)
  final public func update(size: CoreFoundation.CGSize, cornerRadius: CoreFoundation.CGFloat = 0.0, transition: Display.ContainedViewLayoutTransition, beginWithCurrentState: Swift.Bool = true)
  final public func update(size: CoreFoundation.CGSize, cornerRadius: CoreFoundation.CGFloat = 0.0, animator: Display.ControlledTransitionAnimator)
  @objc deinit
}
@objc @_Concurrency.MainActor(unsafe) open class BlurredBackgroundView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public var backgroundCornerRadius: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor(unsafe) public init(color: UIKit.UIColor?, enableBlur: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) public func updateColor(color: UIKit.UIColor, enableBlur: Swift.Bool? = nil, forceKeepBlur: Swift.Bool = false, transition: Display.ContainedViewLayoutTransition)
  @_Concurrency.MainActor(unsafe) public func update(size: CoreFoundation.CGSize, cornerRadius: CoreFoundation.CGFloat = 0.0, maskedCorners: QuartzCore.CACornerMask = [.layerMaxXMaxYCorner, .layerMaxXMinYCorner, .layerMinXMaxYCorner, .layerMinXMinYCorner], transition: Display.ContainedViewLayoutTransition)
  @_Concurrency.MainActor(unsafe) public func update(size: CoreFoundation.CGSize, cornerRadius: CoreFoundation.CGFloat = 0.0, animator: Display.ControlledTransitionAnimator)
  @objc deinit
}
public protocol NavigationBarHeaderView : UIKit.UIView {
}
@objc open class NavigationBar : AsyncDisplayKit.ASDisplayNode {
  public static var defaultSecondaryContentHeight: CoreFoundation.CGFloat {
    get
  }
  public static func backArrowImage(color: UIKit.UIColor) -> UIKit.UIImage?
  public static let titleFont: UIKit.UIFont
  public var backPressed: () -> ()
  public var userInfo: Any?
  public var makeCustomTransitionNode: ((Display.NavigationBar, Swift.Bool) -> Display.CustomNavigationTransitionNode?)?
  public var allowsCustomTransition: (() -> Swift.Bool)?
  final public let stripeNode: AsyncDisplayKit.ASDisplayNode
  final public let clippingNode: Display.SparseNode
  public var contentNode: Display.NavigationBarContentNode? {
    get
  }
  public var secondaryContentNode: AsyncDisplayKit.ASDisplayNode? {
    get
  }
  public var secondaryContentNodeDisplayFraction: CoreFoundation.CGFloat
  public var item: UIKit.UINavigationItem? {
    get
    set(value)
  }
  public var customBackButtonText: Swift.String?
  public var titleView: UIKit.UIView? {
    get
  }
  public var customHeaderContentView: Display.NavigationBarHeaderView? {
    get
    set
  }
  public var layoutSuspended: Swift.Bool
  @objc override dynamic open var accessibilityElements: [Any]? {
    @objc get
    @objc set(value)
  }
  @objc override dynamic open func didLoad()
  public var previousItem: Display.NavigationPreviousAction? {
    get
  }
  final public let backgroundNode: Display.NavigationBackgroundNode
  final public let backButtonNode: Display.NavigationButtonNode
  final public let badgeNode: Display.NavigationBarBadgeNode
  final public let backButtonArrow: Display.ASImageNode
  final public let leftButtonNode: Display.NavigationButtonNode
  final public let rightButtonNode: Display.NavigationButtonNode
  final public let additionalContentNode: Display.SparseNode
  public func reattachAdditionalContentNode()
  public init(presentationData: Display.NavigationBarPresentationData)
  public var isBackgroundVisible: Swift.Bool {
    get
  }
  public func updateBackgroundAlpha(_ alpha: CoreFoundation.CGFloat, transition: Display.ContainedViewLayoutTransition)
  public func updatePresentationData(_ presentationData: Display.NavigationBarPresentationData)
  @objc override dynamic open func layout()
  public func makeTransitionTitleNode(foregroundColor: UIKit.UIColor) -> AsyncDisplayKit.ASDisplayNode?
  public func makeTransitionBackButtonNode(accentColor: UIKit.UIColor) -> Display.NavigationButtonNode?
  public func makeTransitionBackButtonView(accentColor: UIKit.UIColor) -> UIKit.UIView?
  public func makeTransitionRightButtonNode(accentColor: UIKit.UIColor) -> Display.NavigationButtonNode?
  public func makeTransitionBackArrowNode(accentColor: UIKit.UIColor) -> AsyncDisplayKit.ASDisplayNode?
  public func makeTransitionBackArrowView(accentColor: UIKit.UIColor) -> UIKit.UIView?
  public func makeTransitionBadgeNode() -> AsyncDisplayKit.ASDisplayNode?
  public var intrinsicCanTransitionInline: Swift.Bool
  public var shouldTransitionInline: (() -> Swift.Bool)?
  public var passthroughTouches: Swift.Bool
  public var canTransitionInline: Swift.Bool {
    get
  }
  public func contentHeight(defaultHeight: CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  public func setContentNode(_ contentNode: Display.NavigationBarContentNode?, animated: Swift.Bool)
  public func setSecondaryContentNode(_ secondaryContentNode: AsyncDisplayKit.ASDisplayNode?, animated: Swift.Bool = false)
  public func executeBack() -> Swift.Bool
  public func setHidden(_ hidden: Swift.Bool, animated: Swift.Bool)
  @objc override dynamic open func hitTest(_ point: CoreFoundation.CGPoint, with event: UIKit.UIEvent?) -> UIKit.UIView?
  @objc deinit
}
public struct KeyShortcut : Swift.Hashable {
  public init(title: Swift.String = "", input: Swift.String = "", modifiers: UIKit.UIKeyModifierFlags = [], action: @escaping () -> Swift.Void = {})
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Display.KeyShortcut, rhs: Display.KeyShortcut) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension UIKit.UIKeyModifierFlags : Swift.Hashable {
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_Concurrency.MainActor(unsafe) final public class NavigationContainer : AsyncDisplayKit.ASDisplayNode, UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor(unsafe) final public var controllers: [Display.ViewController] {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var isReady: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var isReadyUpdated: (() -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var controllerRemoved: (Display.ViewController) -> Swift.Void
  @_Concurrency.MainActor(unsafe) final public var keyboardViewManager: Display.KeyboardViewManager? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var canHaveKeyboardFocus: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var isInFocus: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public func inFocusUpdated(isInFocus: Swift.Bool)
  @_Concurrency.MainActor(unsafe) final public var overflowInset: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) public init(isFlat: Swift.Bool, controllerRemoved: @escaping (Display.ViewController) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) @objc override final public func didLoad()
  @_Concurrency.MainActor(unsafe) @objc override final public func gestureRecognizerShouldBegin(_ gestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc final public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldBeRequiredToFailBy otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) final public func update(layout: Display.ContainerViewLayout, canBeClosed: Swift.Bool, controllers: [Display.ViewController], transition: Display.ContainedViewLayoutTransition)
  @_Concurrency.MainActor(unsafe) final public func updateAdditionalKeyboardLeftEdgeOffset(_ offset: CoreFoundation.CGFloat, transition: Display.ContainedViewLayoutTransition)
  @_Concurrency.MainActor(unsafe) @objc override final public func hitTest(_ point: CoreFoundation.CGPoint, with event: UIKit.UIEvent?) -> UIKit.UIView?
  @objc deinit
}
@objc final public class NavigationModalFrame : AsyncDisplayKit.ASDisplayNode {
  @objc override dynamic public init()
  final public func update(layout: Display.ContainerViewLayout, transition: Display.ContainedViewLayoutTransition)
  final public func updateDismissal(transition: Display.ContainedViewLayoutTransition, progress: CoreFoundation.CGFloat, additionalProgress: CoreFoundation.CGFloat, completion: @escaping () -> Swift.Void)
  @objc deinit
}
public protocol AccessibilityFocusableNode {
  func accessibilityElementDidBecomeFocused()
}
@objc final public class AccessibilityAreaNode : AsyncDisplayKit.ASDisplayNode {
  final public var activate: (() -> Swift.Bool)?
  final public var increment: (() -> Swift.Void)?
  final public var decrement: (() -> Swift.Void)?
  final public var focused: (() -> Swift.Void)?
  @objc override dynamic public init()
  @objc override final public func accessibilityActivate() -> Swift.Bool
  @objc override final public func hitTest(_ point: CoreFoundation.CGPoint, with event: UIKit.UIEvent?) -> UIKit.UIView?
  @objc override final public func accessibilityElementDidBecomeFocused()
  @objc override final public func accessibilityIncrement()
  @objc override final public func accessibilityDecrement()
  @objc deinit
}
public enum WindowUserInterfaceStyle {
  case light
  case dark
  @available(iOS 12.0, *)
  public init(style: UIKit.UIUserInterfaceStyle)
  public static func == (a: Display.WindowUserInterfaceStyle, b: Display.WindowUserInterfaceStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class PreviewingHostViewDelegate {
  final public let controllerForLocation: (UIKit.UIView, CoreFoundation.CGPoint) -> (UIKit.UIViewController, CoreFoundation.CGRect)?
  final public let commitController: (UIKit.UIViewController) -> Swift.Void
  public init(controllerForLocation: @escaping (UIKit.UIView, CoreFoundation.CGPoint) -> (UIKit.UIViewController, CoreFoundation.CGRect)?, commitController: @escaping (UIKit.UIViewController) -> Swift.Void)
  @objc deinit
}
public protocol PreviewingHostView {
  @available(iOSApplicationExtension 9.0, iOS 9.0, *)
  var previewingDelegate: Display.PreviewingHostViewDelegate? { get }
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class WindowRootViewController : UIKit.UIViewController, UIKit.UIViewControllerPreviewingDelegate {
  @_Concurrency.MainActor(unsafe) @objc override final public var preferredStatusBarStyle: UIKit.UIStatusBarStyle {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public var prefersStatusBarHidden: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public var supportedInterfaceOrientations: UIKit.UIInterfaceOrientationMask {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  @objc deinit
  @_Concurrency.MainActor(unsafe) @objc override final public var preferredScreenEdgesDeferringSystemGestures: UIKit.UIRectEdge {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public var prefersHomeIndicatorAutoHidden: Swift.Bool {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public func viewWillTransition(to size: CoreFoundation.CGSize, with coordinator: UIKit.UIViewControllerTransitionCoordinator)
  @_Concurrency.MainActor(unsafe) @objc override final public func loadView()
  @_Concurrency.MainActor(unsafe) @objc final public func previewingContext(_ previewingContext: UIKit.UIViewControllerPreviewing, viewControllerForLocation location: CoreFoundation.CGPoint) -> UIKit.UIViewController?
  @_Concurrency.MainActor(unsafe) @objc final public func previewingContext(_ previewingContext: UIKit.UIViewControllerPreviewing, commit viewControllerToCommit: UIKit.UIViewController)
  @_Concurrency.MainActor(unsafe) @objc override final public func present(_ viewControllerToPresent: UIKit.UIViewController, animated flag: Swift.Bool, completion: (() -> Swift.Void)? = nil)
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class NativeWindow : UIKit.UIWindow, Display.WindowHost {
  @_Concurrency.MainActor(unsafe) final public var updateSize: ((CoreFoundation.CGSize) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var layoutSubviewsEvent: (() -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var updateIsUpdatingOrientationLayout: ((Swift.Bool) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var updateToInterfaceOrientation: ((UIKit.UIInterfaceOrientation) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var presentController: ((Display.ContainableController, Display.PresentationSurfaceLevel, Swift.Bool, @escaping () -> Swift.Void) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var presentControllerInGlobalOverlay: ((_ controller: Display.ContainableController) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var addGlobalPortalHostViewImpl: ((Display.PortalSourceView) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var hitTestImpl: ((CoreFoundation.CGPoint, UIKit.UIEvent?) -> UIKit.UIView?)?
  @_Concurrency.MainActor(unsafe) final public var presentNativeImpl: ((UIKit.UIViewController) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var invalidateDeferScreenEdgeGestureImpl: (() -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var invalidatePrefersOnScreenNavigationHiddenImpl: (() -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var invalidateSupportedOrientationsImpl: (() -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var cancelInteractiveKeyboardGesturesImpl: (() -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var forEachControllerImpl: (((Display.ContainableController) -> Swift.Void) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) final public var getAccessibilityElementsImpl: (() -> [Any]?)?
  @_Concurrency.MainActor(unsafe) @objc override final public var frame: CoreFoundation.CGRect {
    @objc get
    @objc set(value)
  }
  @_Concurrency.MainActor(unsafe) @objc override final public var bounds: CoreFoundation.CGRect {
    @objc get
    @objc set(value)
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc override final public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override final public func _update(toInterfaceOrientation arg1: Swift.Int32, duration arg2: Swift.Double, force arg3: Swift.Bool)
  @_Concurrency.MainActor(unsafe) final public func present(_ controller: Display.ContainableController, on level: Display.PresentationSurfaceLevel, blockInteraction: Swift.Bool, completion: @escaping () -> Swift.Void)
  @_Concurrency.MainActor(unsafe) final public func presentInGlobalOverlay(_ controller: Display.ContainableController)
  @_Concurrency.MainActor(unsafe) final public func addGlobalPortalHostView(sourceView: Display.PortalSourceView)
  @_Concurrency.MainActor(unsafe) final public func presentNative(_ controller: UIKit.UIViewController)
  @_Concurrency.MainActor(unsafe) @objc override final public func hitTest(_ point: CoreFoundation.CGPoint, with event: UIKit.UIEvent?) -> UIKit.UIView?
  @_Concurrency.MainActor(unsafe) final public func invalidateDeferScreenEdgeGestures()
  @_Concurrency.MainActor(unsafe) final public func invalidatePrefersOnScreenNavigationHidden()
  @_Concurrency.MainActor(unsafe) final public func invalidateSupportedOrientations()
  @_Concurrency.MainActor(unsafe) final public func cancelInteractiveKeyboardGestures()
  @_Concurrency.MainActor(unsafe) final public func forEachController(_ f: (Display.ContainableController) -> Swift.Void)
  @objc deinit
}
public func nativeWindowHostView() -> (UIKit.UIWindow & Display.WindowHost, Display.WindowHostView)
public struct TransformImageNodeContentAnimations : Swift.OptionSet {
  public var rawValue: Swift.Int32
  public init(rawValue: Swift.Int32)
  public static let firstUpdate: Display.TransformImageNodeContentAnimations
  public static let subsequentUpdates: Display.TransformImageNodeContentAnimations
  public typealias ArrayLiteralElement = Display.TransformImageNodeContentAnimations
  public typealias Element = Display.TransformImageNodeContentAnimations
  public typealias RawValue = Swift.Int32
}
@objc @_inheritsConvenienceInitializers open class TransformImageNode : AsyncDisplayKit.ASDisplayNode {
  public var imageUpdated: ((UIKit.UIImage?) -> Swift.Void)?
  public var contentAnimations: Display.TransformImageNodeContentAnimations
  public var image: UIKit.UIImage? {
    get
  }
  public var captureProtected: Swift.Bool {
    get
    set
  }
  @objc override dynamic open var bounds: CoreFoundation.CGRect {
    @objc get
    @objc set
  }
  @objc override dynamic open var frame: CoreFoundation.CGRect {
    @objc get
    @objc set
  }
  @objc deinit
  @objc override dynamic open func didLoad()
  public func reset()
  public func setSignal(_ signal: SwiftSignalKit.Signal<(Display.TransformImageArguments) -> Display.DrawingContext?, SwiftSignalKit.NoError>, attemptSynchronously: Swift.Bool = false, dispatchOnDisplayLink: Swift.Bool = true)
  public func asyncLayout() -> (Display.TransformImageArguments) -> (() -> Swift.Void)
  public class func asyncLayout(_ maybeNode: Display.TransformImageNode?) -> (Display.TransformImageArguments) -> (() -> Display.TransformImageNode)
  public func setOverlayColor(_ color: UIKit.UIColor?, animated: Swift.Bool)
  @objc override dynamic public init()
  @objc override dynamic public init(viewBlock: @escaping AsyncDisplayKit.ASDisplayNodeViewBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc override dynamic public init(layerBlock: @escaping AsyncDisplayKit.ASDisplayNodeLayerBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class TransformImageView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public var imageUpdated: ((UIKit.UIImage?) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) public var contentAnimations: Display.TransformImageNodeContentAnimations
  @_Concurrency.MainActor(unsafe) public var image: UIKit.UIImage? {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var bounds: CoreFoundation.CGRect {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var frame: CoreFoundation.CGRect {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) public var captureProtected: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
  @_Concurrency.MainActor(unsafe) public func reset()
  @_Concurrency.MainActor(unsafe) public func setSignal(_ signal: SwiftSignalKit.Signal<(Display.TransformImageArguments) -> Display.DrawingContext?, SwiftSignalKit.NoError>, attemptSynchronously: Swift.Bool = false, dispatchOnDisplayLink: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) public func asyncLayout() -> (Display.TransformImageArguments) -> (() -> Swift.Void)
  @_Concurrency.MainActor(unsafe) public func setOverlayColor(_ color: UIKit.UIColor?, animated: Swift.Bool)
}
extension Display.ListViewItemHeaderStickDirection : Swift.Equatable {}
extension Display.ListViewItemHeaderStickDirection : Swift.Hashable {}
extension Display.ToolbarActionOption : Swift.Equatable {}
extension Display.ToolbarActionOption : Swift.Hashable {}
extension Display.ActionSheetButtonColor : Swift.Equatable {}
extension Display.ActionSheetButtonColor : Swift.Hashable {}
extension Display.ActionSheetButtonFont : Swift.Equatable {}
extension Display.ActionSheetButtonFont : Swift.Hashable {}
extension Display.NavigationBarContentMode : Swift.Equatable {}
extension Display.NavigationBarContentMode : Swift.Hashable {}
extension Display.ActionSheetControllerThemeBackgroundType : Swift.Equatable {}
extension Display.ActionSheetControllerThemeBackgroundType : Swift.Hashable {}
extension Display.Font.Design : Swift.Equatable {}
extension Display.Font.Design : Swift.Hashable {}
extension Display.Font.Weight : Swift.Equatable {}
extension Display.Font.Weight : Swift.Hashable {}
extension Display.ContainerViewLayoutSizeClass : Swift.Equatable {}
extension Display.ContainerViewLayoutSizeClass : Swift.Hashable {}
extension Display.LayoutOrientation : Swift.Equatable {}
extension Display.LayoutOrientation : Swift.Hashable {}
extension Display.ListViewScrollDirection : Swift.Equatable {}
extension Display.ListViewScrollDirection : Swift.Hashable {}
extension Display.GeneralScrollDirection : Swift.Equatable {}
extension Display.GeneralScrollDirection : Swift.Hashable {}
extension Display.AlertControllerThemeBackgroundType : Swift.Equatable {}
extension Display.AlertControllerThemeBackgroundType : Swift.Hashable {}
extension Display.StatusBarStyle : Swift.Equatable {}
extension Display.StatusBarStyle : Swift.Hashable {}
extension Display.TabBarItemSwipeDirection : Swift.Equatable {}
extension Display.TabBarItemSwipeDirection : Swift.Hashable {}
extension Display.ListViewCenterScrollPositionOverflow : Swift.Equatable {}
extension Display.ListViewCenterScrollPositionOverflow : Swift.Hashable {}
extension Display.ListViewScrollToItemDirectionHint : Swift.Equatable {}
extension Display.ListViewScrollToItemDirectionHint : Swift.Hashable {}
extension Display.ListViewItemOperationDirectionHint : Swift.Equatable {}
extension Display.ListViewItemOperationDirectionHint : Swift.Hashable {}
extension Display.GridNodePreviousItemsTransitionDirectionHint : Swift.Equatable {}
extension Display.GridNodePreviousItemsTransitionDirectionHint : Swift.Hashable {}
extension Display.GradientImageDirection : Swift.Equatable {}
extension Display.GradientImageDirection : Swift.Hashable {}
extension Display.DrawingContextBltMode : Swift.Equatable {}
extension Display.DrawingContextBltMode : Swift.Hashable {}
extension Display.ParsingError : Swift.Equatable {}
extension Display.ParsingError : Swift.Hashable {}
extension Display.DeviceType : Swift.Equatable {}
extension Display.DeviceType : Swift.Hashable {}
extension Display.ActionSheetCheckboxStyle : Swift.Equatable {}
extension Display.ActionSheetCheckboxStyle : Swift.Hashable {}
extension Display.TextNodeCutoutPosition : Swift.Equatable {}
extension Display.TextNodeCutoutPosition : Swift.Hashable {}
extension Display.TextVerticalAlignment : Swift.Equatable {}
extension Display.TextVerticalAlignment : Swift.Hashable {}
extension Display.TapLongTapOrDoubleTapGesture : Swift.Equatable {}
extension Display.TapLongTapOrDoubleTapGesture : Swift.Hashable {}
extension Display.LegacyPresentedControllerPresentation : Swift.Equatable {}
extension Display.LegacyPresentedControllerPresentation : Swift.Hashable {}
extension Display.TextAlertActionType : Swift.Equatable {}
extension Display.TextAlertActionType : Swift.Hashable {}
extension Display.TextAlertContentActionLayout : Swift.Equatable {}
extension Display.TextAlertContentActionLayout : Swift.Hashable {}
extension Display.ViewControllerPresentationAnimation : Swift.Equatable {}
extension Display.ViewControllerPresentationAnimation : Swift.Hashable {}
extension Display.ViewControllerNavigationPresentation : Swift.Equatable {}
extension Display.ViewControllerNavigationPresentation : Swift.Hashable {}
extension Display.TabBarItemContextActionType : Swift.Equatable {}
extension Display.TabBarItemContextActionType : Swift.Hashable {}
extension Display.NavigationStatusBarStyle : Swift.Equatable {}
extension Display.NavigationStatusBarStyle : Swift.Hashable {}
extension Display.NavigationControllerMode : Swift.Equatable {}
extension Display.NavigationControllerMode : Swift.Hashable {}
extension Display.MasterDetailLayoutBlackout : Swift.Hashable {}
extension Display.WindowUserInterfaceStyle : Swift.Equatable {}
extension Display.WindowUserInterfaceStyle : Swift.Hashable {}
